// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "users/v1/UserData.proto" (package "discord_protos.users.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { StringValue } from "../../google/protobuf/wrappers";
import { BoolValue } from "../../google/protobuf/wrappers";
import { UInt64Value } from "../../google/protobuf/wrappers";
import { Timestamp } from "../../google/protobuf/timestamp";
/**
 * @generated from protobuf message discord_protos.users.v1.UserData
 */
export interface UserData {
    /**
     * @generated from protobuf field: map<fixed64, discord_protos.users.v1.UserData.LinkedUser> linked_users = 1
     */
    linkedUsers: {
        [key: string]: UserData_LinkedUser;
    };
    /**
     * @generated from protobuf field: map<uint32, discord_protos.users.v1.UserData.FeatureLimits> safety_feature_limits = 2
     */
    safetyFeatureLimits: {
        [key: number]: UserData_FeatureLimits;
    };
    /**
     * @generated from protobuf field: map<uint32, discord_protos.users.v1.UserData.SafetyFlag> safety_flags = 3
     */
    safetyFlags: {
        [key: number]: UserData_SafetyFlag;
    };
    /**
     * @generated from protobuf field: optional discord_protos.users.v1.UserData.QuestMetadata quest = 4
     */
    quest?: UserData_QuestMetadata;
    /**
     * @generated from protobuf field: optional discord_protos.users.v1.UserData.UserPrimaryGuild primary_guild = 5
     */
    primaryGuild?: UserData_UserPrimaryGuild;
    /**
     * @generated from protobuf field: optional discord_protos.users.v1.UserData.CrossPlatformRestriction cross_platform_restriction = 6
     */
    crossPlatformRestriction?: UserData_CrossPlatformRestriction;
    /**
     * @generated from protobuf field: optional discord_protos.users.v1.UserData.UserCollectibles collectibles = 7
     */
    collectibles?: UserData_UserCollectibles;
    /**
     * @generated from protobuf field: optional discord_protos.users.v1.UserData.SafetyState safety_state = 8
     */
    safetyState?: UserData_SafetyState;
    /**
     * @generated from protobuf field: optional discord_protos.users.v1.UserData.PremiumState premium_state = 9
     */
    premiumState?: UserData_PremiumState;
    /**
     * @generated from protobuf field: optional discord_protos.users.v1.UserData.DisplayNameStyles display_name_styles = 10
     */
    displayNameStyles?: UserData_DisplayNameStyles;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.LinkedUser
 */
export interface UserData_LinkedUser {
    /**
     * @generated from protobuf field: fixed64 user_id = 1
     */
    userId: bigint;
    /**
     * @generated from protobuf field: discord_protos.users.v1.UserData.UserLinkType link_type = 2
     */
    linkType: UserData_UserLinkType;
    /**
     * @generated from protobuf field: discord_protos.users.v1.UserData.UserLinkStatus link_status = 3
     */
    linkStatus: UserData_UserLinkStatus;
    /**
     * @generated from protobuf field: fixed64 requestor_id = 4
     */
    requestorId: bigint;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp created_at = 5
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp updated_at = 6
     */
    updatedAt?: Timestamp;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.RateLimitData
 */
export interface UserData_RateLimitData {
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp limit_expiry = 1
     */
    limitExpiry?: Timestamp;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.FeatureLimits
 */
export interface UserData_FeatureLimits {
    /**
     * @generated from protobuf field: map<uint32, discord_protos.users.v1.UserData.RateLimitData> map = 1
     */
    map: {
        [key: number]: UserData_RateLimitData;
    };
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.SafetyFlag
 */
export interface UserData_SafetyFlag {
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp flag_expiry = 1
     */
    flagExpiry?: Timestamp;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.QuestMetadata
 */
export interface UserData_QuestMetadata {
    /**
     * @generated from protobuf field: uint32 quests_completed = 1
     */
    questsCompleted: number;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.UserPrimaryGuild
 */
export interface UserData_UserPrimaryGuild {
    /**
     * @generated from protobuf field: optional google.protobuf.UInt64Value identity_guild_id = 1
     */
    identityGuildId?: UInt64Value;
    /**
     * @generated from protobuf field: optional google.protobuf.BoolValue identity_enabled = 2
     */
    identityEnabled?: BoolValue;
    /**
     * @generated from protobuf field: optional google.protobuf.StringValue tag = 3
     */
    tag?: StringValue;
    /**
     * @generated from protobuf field: optional google.protobuf.StringValue badge = 4
     */
    badge?: StringValue;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.CrossPlatformRestriction
 */
export interface UserData_CrossPlatformRestriction {
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp restriction_expiry = 1
     */
    restrictionExpiry?: Timestamp;
    /**
     * @generated from protobuf field: fixed64 application_id = 2
     */
    applicationId: bigint;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.UserNameplate
 */
export interface UserData_UserNameplate {
    /**
     * @generated from protobuf field: string asset = 1
     */
    asset: string;
    /**
     * @generated from protobuf field: string palette = 2
     */
    palette: string;
    /**
     * @generated from protobuf field: optional google.protobuf.UInt64Value sku_id = 3
     */
    skuId?: UInt64Value;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp expires_at = 4
     */
    expiresAt?: Timestamp;
    /**
     * @generated from protobuf field: string label = 5
     */
    label: string;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.UserCollectibles
 */
export interface UserData_UserCollectibles {
    /**
     * @generated from protobuf field: optional discord_protos.users.v1.UserData.UserNameplate nameplate = 1
     */
    nameplate?: UserData_UserNameplate;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.NormalState
 */
export interface UserData_NormalState {
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.RestrictedState
 */
export interface UserData_RestrictedState {
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp restricted_until = 1
     */
    restrictedUntil?: Timestamp;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.DeferredActionState
 */
export interface UserData_DeferredActionState {
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp action_deferred_until = 1
     */
    actionDeferredUntil?: Timestamp;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.TempBannedState
 */
export interface UserData_TempBannedState {
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp banned_until = 1
     */
    bannedUntil?: Timestamp;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.BannedState
 */
export interface UserData_BannedState {
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.SafetyState
 */
export interface UserData_SafetyState {
    /**
     * @generated from protobuf oneof: state
     */
    state: {
        oneofKind: "normal";
        /**
         * @generated from protobuf field: discord_protos.users.v1.UserData.NormalState normal = 101
         */
        normal: UserData_NormalState;
    } | {
        oneofKind: "restricted";
        /**
         * @generated from protobuf field: discord_protos.users.v1.UserData.RestrictedState restricted = 102
         */
        restricted: UserData_RestrictedState;
    } | {
        oneofKind: "deferredAction";
        /**
         * @generated from protobuf field: discord_protos.users.v1.UserData.DeferredActionState deferred_action = 103
         */
        deferredAction: UserData_DeferredActionState;
    } | {
        oneofKind: "tempBanned";
        /**
         * @generated from protobuf field: discord_protos.users.v1.UserData.TempBannedState temp_banned = 104
         */
        tempBanned: UserData_TempBannedState;
    } | {
        oneofKind: "banned";
        /**
         * @generated from protobuf field: discord_protos.users.v1.UserData.BannedState banned = 105
         */
        banned: UserData_BannedState;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: discord_protos.users.v1.UserData.SafetyStateReason reason = 1
     */
    reason: UserData_SafetyStateReason;
    /**
     * @generated from protobuf field: repeated discord_protos.users.v1.UserData.SafetyAnnotations annotations = 2
     */
    annotations: UserData_SafetyAnnotations[];
    /**
     * @generated from protobuf field: optional google.protobuf.UInt64Value last_mutation_id = 3
     */
    lastMutationId?: UInt64Value;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.PremiumState
 */
export interface UserData_PremiumState {
    /**
     * @generated from protobuf field: discord_protos.users.v1.UserData.PremiumSource premium_source = 1
     */
    premiumSource: UserData_PremiumSource;
    /**
     * @generated from protobuf field: discord_protos.users.v1.UserData.PremiumSubscriptionType premium_subscription_type = 2
     */
    premiumSubscriptionType: UserData_PremiumSubscriptionType;
    /**
     * @generated from protobuf field: discord_protos.users.v1.UserData.PremiumSubscriptionGroupRole premium_subscription_group_role = 3
     */
    premiumSubscriptionGroupRole: UserData_PremiumSubscriptionGroupRole;
}
/**
 * @generated from protobuf message discord_protos.users.v1.UserData.DisplayNameStyles
 */
export interface UserData_DisplayNameStyles {
    /**
     * @generated from protobuf field: discord_protos.users.v1.UserData.DisplayNameFont font_id = 1
     */
    fontId: UserData_DisplayNameFont;
    /**
     * @generated from protobuf field: discord_protos.users.v1.UserData.DisplayNameEffect effect_id = 2
     */
    effectId: UserData_DisplayNameEffect;
    /**
     * @generated from protobuf field: repeated uint32 colors = 3
     */
    colors: number[];
}
/**
 * @generated from protobuf enum discord_protos.users.v1.UserData.UserLinkType
 */
export enum UserData_UserLinkType {
    /**
     * @generated from protobuf enum value: USER_LINK_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: USER_LINK_TYPE_PARENT = 1;
     */
    PARENT = 1,
    /**
     * @generated from protobuf enum value: USER_LINK_TYPE_CHILD = 2;
     */
    CHILD = 2
}
/**
 * @generated from protobuf enum discord_protos.users.v1.UserData.UserLinkStatus
 */
export enum UserData_UserLinkStatus {
    /**
     * @generated from protobuf enum value: USER_LINK_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: USER_LINK_STATUS_PENDING = 1;
     */
    PENDING = 1,
    /**
     * @generated from protobuf enum value: USER_LINK_STATUS_ACTIVE = 2;
     */
    ACTIVE = 2,
    /**
     * @generated from protobuf enum value: USER_LINK_STATUS_INACTIVE = 3;
     */
    INACTIVE = 3,
    /**
     * @generated from protobuf enum value: USER_LINK_STATUS_DECLINED = 4;
     */
    DECLINED = 4
}
/**
 * @generated from protobuf enum discord_protos.users.v1.UserData.SafetyStateReason
 */
export enum UserData_SafetyStateReason {
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_REASON_UNSPECIFIED = 0;
     */
    REASON_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_DISABLED_SUSPICIOUS_ACTIVITY = 1;
     */
    DISABLED_SUSPICIOUS_ACTIVITY = 1,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_SMITE_REMOVE_EMAIL_VERIFICATION = 2;
     */
    SMITE_REMOVE_EMAIL_VERIFICATION = 2,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_USER_REQUIRED_VERIFICATION_INTERVENTIONS_CLIENT = 3;
     */
    USER_REQUIRED_VERIFICATION_INTERVENTIONS_CLIENT = 3,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_ACTIVE_ASSIGNMENT_COMPLETED = 4;
     */
    ACTIVE_ASSIGNMENT_COMPLETED = 4,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_ACTIVE_ASSIGNMENT_CREATED = 5;
     */
    ACTIVE_ASSIGNMENT_CREATED = 5,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_DEFERRED_ASSIGNMENT_CREATED = 6;
     */
    DEFERRED_ASSIGNMENT_CREATED = 6,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_DEFERRED_ASSIGNMENT_UPGRADED_TO_ACTIVE = 7;
     */
    DEFERRED_ASSIGNMENT_UPGRADED_TO_ACTIVE = 7,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_DEFERRED_ASSIGNMENT_CANCELLED = 8;
     */
    DEFERRED_ASSIGNMENT_CANCELLED = 8,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_ASSIGNMENT_STATE_REPAIRED = 9;
     */
    ASSIGNMENT_STATE_REPAIRED = 9,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_MANUAL_PERMANENT_BAN = 10;
     */
    MANUAL_PERMANENT_BAN = 10,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_SAFETY_SYSTEM_UNBAN = 11;
     */
    SAFETY_SYSTEM_UNBAN = 11,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_GENERIC_AUTOMATED_SAFETY_ACTION = 12;
     */
    GENERIC_AUTOMATED_SAFETY_ACTION = 12,
    /**
     * @generated from protobuf enum value: SAFETY_STATE_REASON_GENERIC_MANUAL_SAFETY_ACTION = 13;
     */
    GENERIC_MANUAL_SAFETY_ACTION = 13
}
/**
 * @generated from protobuf enum discord_protos.users.v1.UserData.SafetyAnnotations
 */
export enum UserData_SafetyAnnotations {
    /**
     * @generated from protobuf enum value: SAFETY_ANNOTATIONS_ANNOTATION_UNSPECIFIED = 0;
     */
    ANNOTATION_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SAFETY_ANNOTATIONS_SPAMMER = 1;
     */
    SPAMMER = 1,
    /**
     * @generated from protobuf enum value: SAFETY_ANNOTATIONS_SELF_DELETED = 2;
     */
    SELF_DELETED = 2,
    /**
     * @generated from protobuf enum value: SAFETY_ANNOTATIONS_SELF_DISABLED = 3;
     */
    SELF_DISABLED = 3,
    /**
     * @generated from protobuf enum value: SAFETY_ANNOTATIONS_UNDERAGE_DELETED = 4;
     */
    UNDERAGE_DELETED = 4,
    /**
     * @generated from protobuf enum value: SAFETY_ANNOTATIONS_SAFETY_POLICY_VIOLATION = 5;
     */
    SAFETY_POLICY_VIOLATION = 5,
    /**
     * @generated from protobuf enum value: SAFETY_ANNOTATIONS_INACTIVITY_DELETED = 6;
     */
    INACTIVITY_DELETED = 6,
    /**
     * @generated from protobuf enum value: SAFETY_ANNOTATIONS_GENERIC_DELETED = 7;
     */
    GENERIC_DELETED = 7
}
/**
 * @generated from protobuf enum discord_protos.users.v1.UserData.PremiumSource
 */
export enum UserData_PremiumSource {
    /**
     * @generated from protobuf enum value: PREMIUM_SOURCE_NONE_UNSPECIFIED = 0;
     */
    NONE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PREMIUM_SOURCE_SUBSCRIPTION = 1;
     */
    SUBSCRIPTION = 1,
    /**
     * @generated from protobuf enum value: PREMIUM_SOURCE_FRACTIONAL_NITRO = 2;
     */
    FRACTIONAL_NITRO = 2,
    /**
     * @generated from protobuf enum value: PREMIUM_SOURCE_REVERSE_TRIAL = 3;
     */
    REVERSE_TRIAL = 3,
    /**
     * @generated from protobuf enum value: PREMIUM_SOURCE_SUBSCRIPTION_GROUP = 4;
     */
    SUBSCRIPTION_GROUP = 4
}
/**
 * @generated from protobuf enum discord_protos.users.v1.UserData.PremiumSubscriptionType
 */
export enum UserData_PremiumSubscriptionType {
    /**
     * @generated from protobuf enum value: PREMIUM_SUBSCRIPTION_TYPE_NONE_UNSPECIFIED = 0;
     */
    NONE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PREMIUM_SUBSCRIPTION_TYPE_BOOST_ONLY = 1;
     */
    BOOST_ONLY = 1,
    /**
     * @generated from protobuf enum value: PREMIUM_SUBSCRIPTION_TYPE_TIER_0 = 2;
     */
    TIER_0 = 2,
    /**
     * @generated from protobuf enum value: PREMIUM_SUBSCRIPTION_TYPE_TIER_1 = 3;
     */
    TIER_1 = 3,
    /**
     * @generated from protobuf enum value: PREMIUM_SUBSCRIPTION_TYPE_TIER_2 = 4;
     */
    TIER_2 = 4
}
/**
 * @generated from protobuf enum discord_protos.users.v1.UserData.PremiumSubscriptionGroupRole
 */
export enum UserData_PremiumSubscriptionGroupRole {
    /**
     * @generated from protobuf enum value: PREMIUM_SUBSCRIPTION_GROUP_ROLE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PREMIUM_SUBSCRIPTION_GROUP_ROLE_PRIMARY = 1;
     */
    PRIMARY = 1,
    /**
     * @generated from protobuf enum value: PREMIUM_SUBSCRIPTION_GROUP_ROLE_MEMBER = 2;
     */
    MEMBER = 2
}
/**
 * @generated from protobuf enum discord_protos.users.v1.UserData.DisplayNameFont
 */
export enum UserData_DisplayNameFont {
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_DEFAULT = 11;
     */
    DEFAULT = 11,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_BANGERS = 1;
     */
    BANGERS = 1,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_BIO_RHYME = 2;
     */
    BIO_RHYME = 2,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_CHERRY_BOMB = 3;
     */
    CHERRY_BOMB = 3,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_CHICLE = 4;
     */
    CHICLE = 4,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_COMPAGNON = 5;
     */
    COMPAGNON = 5,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_MUSEO_MODERNO = 6;
     */
    MUSEO_MODERNO = 6,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_NEO_CASTEL = 7;
     */
    NEO_CASTEL = 7,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_PIXELIFY = 8;
     */
    PIXELIFY = 8,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_RIBES = 9;
     */
    RIBES = 9,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_SINISTRE = 10;
     */
    SINISTRE = 10,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_FONT_ZILLA_SLAB = 12;
     */
    ZILLA_SLAB = 12
}
/**
 * @generated from protobuf enum discord_protos.users.v1.UserData.DisplayNameEffect
 */
export enum UserData_DisplayNameEffect {
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_EFFECT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_EFFECT_SOLID = 1;
     */
    SOLID = 1,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_EFFECT_GRADIENT = 2;
     */
    GRADIENT = 2,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_EFFECT_NEON = 3;
     */
    NEON = 3,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_EFFECT_TOON = 4;
     */
    TOON = 4,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_EFFECT_POP = 5;
     */
    POP = 5,
    /**
     * @generated from protobuf enum value: DISPLAY_NAME_EFFECT_GLOW = 6;
     */
    GLOW = 6
}
// @generated message type with reflection information, may provide speed optimized methods
class UserData$Type extends MessageType<UserData> {
    constructor() {
        super("discord_protos.users.v1.UserData", [
            { no: 1, name: "linked_users", kind: "map", K: 6 /*ScalarType.FIXED64*/, V: { kind: "message", T: () => UserData_LinkedUser } },
            { no: 2, name: "safety_feature_limits", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => UserData_FeatureLimits } },
            { no: 3, name: "safety_flags", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => UserData_SafetyFlag } },
            { no: 4, name: "quest", kind: "message", T: () => UserData_QuestMetadata },
            { no: 5, name: "primary_guild", kind: "message", T: () => UserData_UserPrimaryGuild },
            { no: 6, name: "cross_platform_restriction", kind: "message", T: () => UserData_CrossPlatformRestriction },
            { no: 7, name: "collectibles", kind: "message", T: () => UserData_UserCollectibles },
            { no: 8, name: "safety_state", kind: "message", T: () => UserData_SafetyState },
            { no: 9, name: "premium_state", kind: "message", T: () => UserData_PremiumState },
            { no: 10, name: "display_name_styles", kind: "message", T: () => UserData_DisplayNameStyles }
        ]);
    }
    create(value?: PartialMessage<UserData>): UserData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.linkedUsers = {};
        message.safetyFeatureLimits = {};
        message.safetyFlags = {};
        if (value !== undefined)
            reflectionMergePartial<UserData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData): UserData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<fixed64, discord_protos.users.v1.UserData.LinkedUser> linked_users */ 1:
                    this.binaryReadMap1(message.linkedUsers, reader, options);
                    break;
                case /* map<uint32, discord_protos.users.v1.UserData.FeatureLimits> safety_feature_limits */ 2:
                    this.binaryReadMap2(message.safetyFeatureLimits, reader, options);
                    break;
                case /* map<uint32, discord_protos.users.v1.UserData.SafetyFlag> safety_flags */ 3:
                    this.binaryReadMap3(message.safetyFlags, reader, options);
                    break;
                case /* optional discord_protos.users.v1.UserData.QuestMetadata quest */ 4:
                    message.quest = UserData_QuestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.quest);
                    break;
                case /* optional discord_protos.users.v1.UserData.UserPrimaryGuild primary_guild */ 5:
                    message.primaryGuild = UserData_UserPrimaryGuild.internalBinaryRead(reader, reader.uint32(), options, message.primaryGuild);
                    break;
                case /* optional discord_protos.users.v1.UserData.CrossPlatformRestriction cross_platform_restriction */ 6:
                    message.crossPlatformRestriction = UserData_CrossPlatformRestriction.internalBinaryRead(reader, reader.uint32(), options, message.crossPlatformRestriction);
                    break;
                case /* optional discord_protos.users.v1.UserData.UserCollectibles collectibles */ 7:
                    message.collectibles = UserData_UserCollectibles.internalBinaryRead(reader, reader.uint32(), options, message.collectibles);
                    break;
                case /* optional discord_protos.users.v1.UserData.SafetyState safety_state */ 8:
                    message.safetyState = UserData_SafetyState.internalBinaryRead(reader, reader.uint32(), options, message.safetyState);
                    break;
                case /* optional discord_protos.users.v1.UserData.PremiumState premium_state */ 9:
                    message.premiumState = UserData_PremiumState.internalBinaryRead(reader, reader.uint32(), options, message.premiumState);
                    break;
                case /* optional discord_protos.users.v1.UserData.DisplayNameStyles display_name_styles */ 10:
                    message.displayNameStyles = UserData_DisplayNameStyles.internalBinaryRead(reader, reader.uint32(), options, message.displayNameStyles);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: UserData["linkedUsers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UserData["linkedUsers"] | undefined, val: UserData["linkedUsers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed64().toString();
                    break;
                case 2:
                    val = UserData_LinkedUser.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for discord_protos.users.v1.UserData.linked_users");
            }
        }
        map[key ?? "0"] = val ?? UserData_LinkedUser.create();
    }
    private binaryReadMap2(map: UserData["safetyFeatureLimits"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UserData["safetyFeatureLimits"] | undefined, val: UserData["safetyFeatureLimits"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = UserData_FeatureLimits.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for discord_protos.users.v1.UserData.safety_feature_limits");
            }
        }
        map[key ?? 0] = val ?? UserData_FeatureLimits.create();
    }
    private binaryReadMap3(map: UserData["safetyFlags"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UserData["safetyFlags"] | undefined, val: UserData["safetyFlags"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = UserData_SafetyFlag.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for discord_protos.users.v1.UserData.safety_flags");
            }
        }
        map[key ?? 0] = val ?? UserData_SafetyFlag.create();
    }
    internalBinaryWrite(message: UserData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<fixed64, discord_protos.users.v1.UserData.LinkedUser> linked_users = 1; */
        for (let k of globalThis.Object.keys(message.linkedUsers)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).fixed64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            UserData_LinkedUser.internalBinaryWrite(message.linkedUsers[k], writer, options);
            writer.join().join();
        }
        /* map<uint32, discord_protos.users.v1.UserData.FeatureLimits> safety_feature_limits = 2; */
        for (let k of globalThis.Object.keys(message.safetyFeatureLimits)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            UserData_FeatureLimits.internalBinaryWrite(message.safetyFeatureLimits[k as any], writer, options);
            writer.join().join();
        }
        /* map<uint32, discord_protos.users.v1.UserData.SafetyFlag> safety_flags = 3; */
        for (let k of globalThis.Object.keys(message.safetyFlags)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            UserData_SafetyFlag.internalBinaryWrite(message.safetyFlags[k as any], writer, options);
            writer.join().join();
        }
        /* optional discord_protos.users.v1.UserData.QuestMetadata quest = 4; */
        if (message.quest)
            UserData_QuestMetadata.internalBinaryWrite(message.quest, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.users.v1.UserData.UserPrimaryGuild primary_guild = 5; */
        if (message.primaryGuild)
            UserData_UserPrimaryGuild.internalBinaryWrite(message.primaryGuild, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.users.v1.UserData.CrossPlatformRestriction cross_platform_restriction = 6; */
        if (message.crossPlatformRestriction)
            UserData_CrossPlatformRestriction.internalBinaryWrite(message.crossPlatformRestriction, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.users.v1.UserData.UserCollectibles collectibles = 7; */
        if (message.collectibles)
            UserData_UserCollectibles.internalBinaryWrite(message.collectibles, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.users.v1.UserData.SafetyState safety_state = 8; */
        if (message.safetyState)
            UserData_SafetyState.internalBinaryWrite(message.safetyState, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.users.v1.UserData.PremiumState premium_state = 9; */
        if (message.premiumState)
            UserData_PremiumState.internalBinaryWrite(message.premiumState, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.users.v1.UserData.DisplayNameStyles display_name_styles = 10; */
        if (message.displayNameStyles)
            UserData_DisplayNameStyles.internalBinaryWrite(message.displayNameStyles, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData
 */
export const UserData = new UserData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_LinkedUser$Type extends MessageType<UserData_LinkedUser> {
    constructor() {
        super("discord_protos.users.v1.UserData.LinkedUser", [
            { no: 1, name: "user_id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "link_type", kind: "enum", T: () => ["discord_protos.users.v1.UserData.UserLinkType", UserData_UserLinkType, "USER_LINK_TYPE_"] },
            { no: 3, name: "link_status", kind: "enum", T: () => ["discord_protos.users.v1.UserData.UserLinkStatus", UserData_UserLinkStatus, "USER_LINK_STATUS_"] },
            { no: 4, name: "requestor_id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 6, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<UserData_LinkedUser>): UserData_LinkedUser {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = 0n;
        message.linkType = 0;
        message.linkStatus = 0;
        message.requestorId = 0n;
        if (value !== undefined)
            reflectionMergePartial<UserData_LinkedUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_LinkedUser): UserData_LinkedUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed64 user_id */ 1:
                    message.userId = reader.fixed64().toBigInt();
                    break;
                case /* discord_protos.users.v1.UserData.UserLinkType link_type */ 2:
                    message.linkType = reader.int32();
                    break;
                case /* discord_protos.users.v1.UserData.UserLinkStatus link_status */ 3:
                    message.linkStatus = reader.int32();
                    break;
                case /* fixed64 requestor_id */ 4:
                    message.requestorId = reader.fixed64().toBigInt();
                    break;
                case /* optional google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* optional google.protobuf.Timestamp updated_at */ 6:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_LinkedUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed64 user_id = 1; */
        if (message.userId !== 0n)
            writer.tag(1, WireType.Bit64).fixed64(message.userId);
        /* discord_protos.users.v1.UserData.UserLinkType link_type = 2; */
        if (message.linkType !== 0)
            writer.tag(2, WireType.Varint).int32(message.linkType);
        /* discord_protos.users.v1.UserData.UserLinkStatus link_status = 3; */
        if (message.linkStatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.linkStatus);
        /* fixed64 requestor_id = 4; */
        if (message.requestorId !== 0n)
            writer.tag(4, WireType.Bit64).fixed64(message.requestorId);
        /* optional google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.Timestamp updated_at = 6; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.LinkedUser
 */
export const UserData_LinkedUser = new UserData_LinkedUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_RateLimitData$Type extends MessageType<UserData_RateLimitData> {
    constructor() {
        super("discord_protos.users.v1.UserData.RateLimitData", [
            { no: 1, name: "limit_expiry", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<UserData_RateLimitData>): UserData_RateLimitData {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserData_RateLimitData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_RateLimitData): UserData_RateLimitData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Timestamp limit_expiry */ 1:
                    message.limitExpiry = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.limitExpiry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_RateLimitData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.Timestamp limit_expiry = 1; */
        if (message.limitExpiry)
            Timestamp.internalBinaryWrite(message.limitExpiry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.RateLimitData
 */
export const UserData_RateLimitData = new UserData_RateLimitData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_FeatureLimits$Type extends MessageType<UserData_FeatureLimits> {
    constructor() {
        super("discord_protos.users.v1.UserData.FeatureLimits", [
            { no: 1, name: "map", kind: "map", K: 13 /*ScalarType.UINT32*/, V: { kind: "message", T: () => UserData_RateLimitData } }
        ]);
    }
    create(value?: PartialMessage<UserData_FeatureLimits>): UserData_FeatureLimits {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        if (value !== undefined)
            reflectionMergePartial<UserData_FeatureLimits>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_FeatureLimits): UserData_FeatureLimits {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<uint32, discord_protos.users.v1.UserData.RateLimitData> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: UserData_FeatureLimits["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UserData_FeatureLimits["map"] | undefined, val: UserData_FeatureLimits["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint32();
                    break;
                case 2:
                    val = UserData_RateLimitData.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for discord_protos.users.v1.UserData.FeatureLimits.map");
            }
        }
        map[key ?? 0] = val ?? UserData_RateLimitData.create();
    }
    internalBinaryWrite(message: UserData_FeatureLimits, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<uint32, discord_protos.users.v1.UserData.RateLimitData> map = 1; */
        for (let k of globalThis.Object.keys(message.map)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            UserData_RateLimitData.internalBinaryWrite(message.map[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.FeatureLimits
 */
export const UserData_FeatureLimits = new UserData_FeatureLimits$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_SafetyFlag$Type extends MessageType<UserData_SafetyFlag> {
    constructor() {
        super("discord_protos.users.v1.UserData.SafetyFlag", [
            { no: 1, name: "flag_expiry", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<UserData_SafetyFlag>): UserData_SafetyFlag {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserData_SafetyFlag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_SafetyFlag): UserData_SafetyFlag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Timestamp flag_expiry */ 1:
                    message.flagExpiry = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.flagExpiry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_SafetyFlag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.Timestamp flag_expiry = 1; */
        if (message.flagExpiry)
            Timestamp.internalBinaryWrite(message.flagExpiry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.SafetyFlag
 */
export const UserData_SafetyFlag = new UserData_SafetyFlag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_QuestMetadata$Type extends MessageType<UserData_QuestMetadata> {
    constructor() {
        super("discord_protos.users.v1.UserData.QuestMetadata", [
            { no: 1, name: "quests_completed", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UserData_QuestMetadata>): UserData_QuestMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.questsCompleted = 0;
        if (value !== undefined)
            reflectionMergePartial<UserData_QuestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_QuestMetadata): UserData_QuestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 quests_completed */ 1:
                    message.questsCompleted = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_QuestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 quests_completed = 1; */
        if (message.questsCompleted !== 0)
            writer.tag(1, WireType.Varint).uint32(message.questsCompleted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.QuestMetadata
 */
export const UserData_QuestMetadata = new UserData_QuestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_UserPrimaryGuild$Type extends MessageType<UserData_UserPrimaryGuild> {
    constructor() {
        super("discord_protos.users.v1.UserData.UserPrimaryGuild", [
            { no: 1, name: "identity_guild_id", kind: "message", T: () => UInt64Value },
            { no: 2, name: "identity_enabled", kind: "message", T: () => BoolValue },
            { no: 3, name: "tag", kind: "message", T: () => StringValue },
            { no: 4, name: "badge", kind: "message", T: () => StringValue }
        ]);
    }
    create(value?: PartialMessage<UserData_UserPrimaryGuild>): UserData_UserPrimaryGuild {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserData_UserPrimaryGuild>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_UserPrimaryGuild): UserData_UserPrimaryGuild {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.UInt64Value identity_guild_id */ 1:
                    message.identityGuildId = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.identityGuildId);
                    break;
                case /* optional google.protobuf.BoolValue identity_enabled */ 2:
                    message.identityEnabled = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.identityEnabled);
                    break;
                case /* optional google.protobuf.StringValue tag */ 3:
                    message.tag = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.tag);
                    break;
                case /* optional google.protobuf.StringValue badge */ 4:
                    message.badge = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.badge);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_UserPrimaryGuild, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.UInt64Value identity_guild_id = 1; */
        if (message.identityGuildId)
            UInt64Value.internalBinaryWrite(message.identityGuildId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.BoolValue identity_enabled = 2; */
        if (message.identityEnabled)
            BoolValue.internalBinaryWrite(message.identityEnabled, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.StringValue tag = 3; */
        if (message.tag)
            StringValue.internalBinaryWrite(message.tag, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.StringValue badge = 4; */
        if (message.badge)
            StringValue.internalBinaryWrite(message.badge, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.UserPrimaryGuild
 */
export const UserData_UserPrimaryGuild = new UserData_UserPrimaryGuild$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_CrossPlatformRestriction$Type extends MessageType<UserData_CrossPlatformRestriction> {
    constructor() {
        super("discord_protos.users.v1.UserData.CrossPlatformRestriction", [
            { no: 1, name: "restriction_expiry", kind: "message", T: () => Timestamp },
            { no: 2, name: "application_id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UserData_CrossPlatformRestriction>): UserData_CrossPlatformRestriction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.applicationId = 0n;
        if (value !== undefined)
            reflectionMergePartial<UserData_CrossPlatformRestriction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_CrossPlatformRestriction): UserData_CrossPlatformRestriction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Timestamp restriction_expiry */ 1:
                    message.restrictionExpiry = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.restrictionExpiry);
                    break;
                case /* fixed64 application_id */ 2:
                    message.applicationId = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_CrossPlatformRestriction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.Timestamp restriction_expiry = 1; */
        if (message.restrictionExpiry)
            Timestamp.internalBinaryWrite(message.restrictionExpiry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* fixed64 application_id = 2; */
        if (message.applicationId !== 0n)
            writer.tag(2, WireType.Bit64).fixed64(message.applicationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.CrossPlatformRestriction
 */
export const UserData_CrossPlatformRestriction = new UserData_CrossPlatformRestriction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_UserNameplate$Type extends MessageType<UserData_UserNameplate> {
    constructor() {
        super("discord_protos.users.v1.UserData.UserNameplate", [
            { no: 1, name: "asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "palette", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sku_id", kind: "message", T: () => UInt64Value },
            { no: 4, name: "expires_at", kind: "message", T: () => Timestamp },
            { no: 5, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserData_UserNameplate>): UserData_UserNameplate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.asset = "";
        message.palette = "";
        message.label = "";
        if (value !== undefined)
            reflectionMergePartial<UserData_UserNameplate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_UserNameplate): UserData_UserNameplate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string asset */ 1:
                    message.asset = reader.string();
                    break;
                case /* string palette */ 2:
                    message.palette = reader.string();
                    break;
                case /* optional google.protobuf.UInt64Value sku_id */ 3:
                    message.skuId = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.skuId);
                    break;
                case /* optional google.protobuf.Timestamp expires_at */ 4:
                    message.expiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
                    break;
                case /* string label */ 5:
                    message.label = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_UserNameplate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string asset = 1; */
        if (message.asset !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.asset);
        /* string palette = 2; */
        if (message.palette !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.palette);
        /* optional google.protobuf.UInt64Value sku_id = 3; */
        if (message.skuId)
            UInt64Value.internalBinaryWrite(message.skuId, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.Timestamp expires_at = 4; */
        if (message.expiresAt)
            Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string label = 5; */
        if (message.label !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.label);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.UserNameplate
 */
export const UserData_UserNameplate = new UserData_UserNameplate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_UserCollectibles$Type extends MessageType<UserData_UserCollectibles> {
    constructor() {
        super("discord_protos.users.v1.UserData.UserCollectibles", [
            { no: 1, name: "nameplate", kind: "message", T: () => UserData_UserNameplate }
        ]);
    }
    create(value?: PartialMessage<UserData_UserCollectibles>): UserData_UserCollectibles {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserData_UserCollectibles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_UserCollectibles): UserData_UserCollectibles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.users.v1.UserData.UserNameplate nameplate */ 1:
                    message.nameplate = UserData_UserNameplate.internalBinaryRead(reader, reader.uint32(), options, message.nameplate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_UserCollectibles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.users.v1.UserData.UserNameplate nameplate = 1; */
        if (message.nameplate)
            UserData_UserNameplate.internalBinaryWrite(message.nameplate, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.UserCollectibles
 */
export const UserData_UserCollectibles = new UserData_UserCollectibles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_NormalState$Type extends MessageType<UserData_NormalState> {
    constructor() {
        super("discord_protos.users.v1.UserData.NormalState", []);
    }
    create(value?: PartialMessage<UserData_NormalState>): UserData_NormalState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserData_NormalState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_NormalState): UserData_NormalState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_NormalState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.NormalState
 */
export const UserData_NormalState = new UserData_NormalState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_RestrictedState$Type extends MessageType<UserData_RestrictedState> {
    constructor() {
        super("discord_protos.users.v1.UserData.RestrictedState", [
            { no: 1, name: "restricted_until", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<UserData_RestrictedState>): UserData_RestrictedState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserData_RestrictedState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_RestrictedState): UserData_RestrictedState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Timestamp restricted_until */ 1:
                    message.restrictedUntil = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.restrictedUntil);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_RestrictedState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.Timestamp restricted_until = 1; */
        if (message.restrictedUntil)
            Timestamp.internalBinaryWrite(message.restrictedUntil, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.RestrictedState
 */
export const UserData_RestrictedState = new UserData_RestrictedState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_DeferredActionState$Type extends MessageType<UserData_DeferredActionState> {
    constructor() {
        super("discord_protos.users.v1.UserData.DeferredActionState", [
            { no: 1, name: "action_deferred_until", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<UserData_DeferredActionState>): UserData_DeferredActionState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserData_DeferredActionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_DeferredActionState): UserData_DeferredActionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Timestamp action_deferred_until */ 1:
                    message.actionDeferredUntil = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.actionDeferredUntil);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_DeferredActionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.Timestamp action_deferred_until = 1; */
        if (message.actionDeferredUntil)
            Timestamp.internalBinaryWrite(message.actionDeferredUntil, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.DeferredActionState
 */
export const UserData_DeferredActionState = new UserData_DeferredActionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_TempBannedState$Type extends MessageType<UserData_TempBannedState> {
    constructor() {
        super("discord_protos.users.v1.UserData.TempBannedState", [
            { no: 1, name: "banned_until", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<UserData_TempBannedState>): UserData_TempBannedState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserData_TempBannedState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_TempBannedState): UserData_TempBannedState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.Timestamp banned_until */ 1:
                    message.bannedUntil = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.bannedUntil);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_TempBannedState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.Timestamp banned_until = 1; */
        if (message.bannedUntil)
            Timestamp.internalBinaryWrite(message.bannedUntil, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.TempBannedState
 */
export const UserData_TempBannedState = new UserData_TempBannedState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_BannedState$Type extends MessageType<UserData_BannedState> {
    constructor() {
        super("discord_protos.users.v1.UserData.BannedState", []);
    }
    create(value?: PartialMessage<UserData_BannedState>): UserData_BannedState {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserData_BannedState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_BannedState): UserData_BannedState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_BannedState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.BannedState
 */
export const UserData_BannedState = new UserData_BannedState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_SafetyState$Type extends MessageType<UserData_SafetyState> {
    constructor() {
        super("discord_protos.users.v1.UserData.SafetyState", [
            { no: 101, name: "normal", kind: "message", oneof: "state", T: () => UserData_NormalState },
            { no: 102, name: "restricted", kind: "message", oneof: "state", T: () => UserData_RestrictedState },
            { no: 103, name: "deferred_action", kind: "message", oneof: "state", T: () => UserData_DeferredActionState },
            { no: 104, name: "temp_banned", kind: "message", oneof: "state", T: () => UserData_TempBannedState },
            { no: 105, name: "banned", kind: "message", oneof: "state", T: () => UserData_BannedState },
            { no: 1, name: "reason", kind: "enum", T: () => ["discord_protos.users.v1.UserData.SafetyStateReason", UserData_SafetyStateReason, "SAFETY_STATE_REASON_"] },
            { no: 2, name: "annotations", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["discord_protos.users.v1.UserData.SafetyAnnotations", UserData_SafetyAnnotations, "SAFETY_ANNOTATIONS_"] },
            { no: 3, name: "last_mutation_id", kind: "message", T: () => UInt64Value }
        ]);
    }
    create(value?: PartialMessage<UserData_SafetyState>): UserData_SafetyState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = { oneofKind: undefined };
        message.reason = 0;
        message.annotations = [];
        if (value !== undefined)
            reflectionMergePartial<UserData_SafetyState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_SafetyState): UserData_SafetyState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* discord_protos.users.v1.UserData.NormalState normal */ 101:
                    message.state = {
                        oneofKind: "normal",
                        normal: UserData_NormalState.internalBinaryRead(reader, reader.uint32(), options, (message.state as any).normal)
                    };
                    break;
                case /* discord_protos.users.v1.UserData.RestrictedState restricted */ 102:
                    message.state = {
                        oneofKind: "restricted",
                        restricted: UserData_RestrictedState.internalBinaryRead(reader, reader.uint32(), options, (message.state as any).restricted)
                    };
                    break;
                case /* discord_protos.users.v1.UserData.DeferredActionState deferred_action */ 103:
                    message.state = {
                        oneofKind: "deferredAction",
                        deferredAction: UserData_DeferredActionState.internalBinaryRead(reader, reader.uint32(), options, (message.state as any).deferredAction)
                    };
                    break;
                case /* discord_protos.users.v1.UserData.TempBannedState temp_banned */ 104:
                    message.state = {
                        oneofKind: "tempBanned",
                        tempBanned: UserData_TempBannedState.internalBinaryRead(reader, reader.uint32(), options, (message.state as any).tempBanned)
                    };
                    break;
                case /* discord_protos.users.v1.UserData.BannedState banned */ 105:
                    message.state = {
                        oneofKind: "banned",
                        banned: UserData_BannedState.internalBinaryRead(reader, reader.uint32(), options, (message.state as any).banned)
                    };
                    break;
                case /* discord_protos.users.v1.UserData.SafetyStateReason reason */ 1:
                    message.reason = reader.int32();
                    break;
                case /* repeated discord_protos.users.v1.UserData.SafetyAnnotations annotations */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.annotations.push(reader.int32());
                    else
                        message.annotations.push(reader.int32());
                    break;
                case /* optional google.protobuf.UInt64Value last_mutation_id */ 3:
                    message.lastMutationId = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.lastMutationId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_SafetyState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* discord_protos.users.v1.UserData.SafetyStateReason reason = 1; */
        if (message.reason !== 0)
            writer.tag(1, WireType.Varint).int32(message.reason);
        /* repeated discord_protos.users.v1.UserData.SafetyAnnotations annotations = 2; */
        if (message.annotations.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.annotations.length; i++)
                writer.int32(message.annotations[i]);
            writer.join();
        }
        /* optional google.protobuf.UInt64Value last_mutation_id = 3; */
        if (message.lastMutationId)
            UInt64Value.internalBinaryWrite(message.lastMutationId, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.users.v1.UserData.NormalState normal = 101; */
        if (message.state.oneofKind === "normal")
            UserData_NormalState.internalBinaryWrite(message.state.normal, writer.tag(101, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.users.v1.UserData.RestrictedState restricted = 102; */
        if (message.state.oneofKind === "restricted")
            UserData_RestrictedState.internalBinaryWrite(message.state.restricted, writer.tag(102, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.users.v1.UserData.DeferredActionState deferred_action = 103; */
        if (message.state.oneofKind === "deferredAction")
            UserData_DeferredActionState.internalBinaryWrite(message.state.deferredAction, writer.tag(103, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.users.v1.UserData.TempBannedState temp_banned = 104; */
        if (message.state.oneofKind === "tempBanned")
            UserData_TempBannedState.internalBinaryWrite(message.state.tempBanned, writer.tag(104, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.users.v1.UserData.BannedState banned = 105; */
        if (message.state.oneofKind === "banned")
            UserData_BannedState.internalBinaryWrite(message.state.banned, writer.tag(105, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.SafetyState
 */
export const UserData_SafetyState = new UserData_SafetyState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_PremiumState$Type extends MessageType<UserData_PremiumState> {
    constructor() {
        super("discord_protos.users.v1.UserData.PremiumState", [
            { no: 1, name: "premium_source", kind: "enum", T: () => ["discord_protos.users.v1.UserData.PremiumSource", UserData_PremiumSource, "PREMIUM_SOURCE_"] },
            { no: 2, name: "premium_subscription_type", kind: "enum", T: () => ["discord_protos.users.v1.UserData.PremiumSubscriptionType", UserData_PremiumSubscriptionType, "PREMIUM_SUBSCRIPTION_TYPE_"] },
            { no: 3, name: "premium_subscription_group_role", kind: "enum", T: () => ["discord_protos.users.v1.UserData.PremiumSubscriptionGroupRole", UserData_PremiumSubscriptionGroupRole, "PREMIUM_SUBSCRIPTION_GROUP_ROLE_"] }
        ]);
    }
    create(value?: PartialMessage<UserData_PremiumState>): UserData_PremiumState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.premiumSource = 0;
        message.premiumSubscriptionType = 0;
        message.premiumSubscriptionGroupRole = 0;
        if (value !== undefined)
            reflectionMergePartial<UserData_PremiumState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_PremiumState): UserData_PremiumState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* discord_protos.users.v1.UserData.PremiumSource premium_source */ 1:
                    message.premiumSource = reader.int32();
                    break;
                case /* discord_protos.users.v1.UserData.PremiumSubscriptionType premium_subscription_type */ 2:
                    message.premiumSubscriptionType = reader.int32();
                    break;
                case /* discord_protos.users.v1.UserData.PremiumSubscriptionGroupRole premium_subscription_group_role */ 3:
                    message.premiumSubscriptionGroupRole = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_PremiumState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* discord_protos.users.v1.UserData.PremiumSource premium_source = 1; */
        if (message.premiumSource !== 0)
            writer.tag(1, WireType.Varint).int32(message.premiumSource);
        /* discord_protos.users.v1.UserData.PremiumSubscriptionType premium_subscription_type = 2; */
        if (message.premiumSubscriptionType !== 0)
            writer.tag(2, WireType.Varint).int32(message.premiumSubscriptionType);
        /* discord_protos.users.v1.UserData.PremiumSubscriptionGroupRole premium_subscription_group_role = 3; */
        if (message.premiumSubscriptionGroupRole !== 0)
            writer.tag(3, WireType.Varint).int32(message.premiumSubscriptionGroupRole);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.PremiumState
 */
export const UserData_PremiumState = new UserData_PremiumState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserData_DisplayNameStyles$Type extends MessageType<UserData_DisplayNameStyles> {
    constructor() {
        super("discord_protos.users.v1.UserData.DisplayNameStyles", [
            { no: 1, name: "font_id", kind: "enum", T: () => ["discord_protos.users.v1.UserData.DisplayNameFont", UserData_DisplayNameFont, "DISPLAY_NAME_FONT_"] },
            { no: 2, name: "effect_id", kind: "enum", T: () => ["discord_protos.users.v1.UserData.DisplayNameEffect", UserData_DisplayNameEffect, "DISPLAY_NAME_EFFECT_"] },
            { no: 3, name: "colors", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UserData_DisplayNameStyles>): UserData_DisplayNameStyles {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fontId = 0;
        message.effectId = 0;
        message.colors = [];
        if (value !== undefined)
            reflectionMergePartial<UserData_DisplayNameStyles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserData_DisplayNameStyles): UserData_DisplayNameStyles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* discord_protos.users.v1.UserData.DisplayNameFont font_id */ 1:
                    message.fontId = reader.int32();
                    break;
                case /* discord_protos.users.v1.UserData.DisplayNameEffect effect_id */ 2:
                    message.effectId = reader.int32();
                    break;
                case /* repeated uint32 colors */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.colors.push(reader.uint32());
                    else
                        message.colors.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserData_DisplayNameStyles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* discord_protos.users.v1.UserData.DisplayNameFont font_id = 1; */
        if (message.fontId !== 0)
            writer.tag(1, WireType.Varint).int32(message.fontId);
        /* discord_protos.users.v1.UserData.DisplayNameEffect effect_id = 2; */
        if (message.effectId !== 0)
            writer.tag(2, WireType.Varint).int32(message.effectId);
        /* repeated uint32 colors = 3; */
        if (message.colors.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.colors.length; i++)
                writer.uint32(message.colors[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.users.v1.UserData.DisplayNameStyles
 */
export const UserData_DisplayNameStyles = new UserData_DisplayNameStyles$Type();
