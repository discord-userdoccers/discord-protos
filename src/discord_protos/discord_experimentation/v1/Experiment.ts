// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "discord_experimentation/v1/Experiment.proto" (package "discord_protos.discord_experimentation.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UInt64Value } from "../../google/protobuf/wrappers";
import { UInt32Value } from "../../google/protobuf/wrappers";
import { StringValue } from "../../google/protobuf/wrappers";
import { Timestamp } from "../../google/protobuf/timestamp";
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment
 */
export interface Experiment {
    /**
     * @generated from protobuf field: fixed64 id = 1
     */
    id: bigint;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp created_at = 3
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: fixed64 creator_id = 4
     */
    creatorId: bigint;
    /**
     * @generated from protobuf field: int32 version = 5
     */
    version: number;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp edited_at = 6
     */
    editedAt?: Timestamp;
    /**
     * @generated from protobuf field: fixed64 editor_id = 7
     */
    editorId: bigint;
    /**
     * @generated from protobuf field: string title = 8
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 9
     */
    description: string;
    /**
     * @generated from protobuf field: optional google.protobuf.StringValue hypothesis = 10
     */
    hypothesis?: StringValue;
    /**
     * @generated from protobuf field: optional google.protobuf.StringValue tech_spec_link = 11
     */
    techSpecLink?: StringValue;
    /**
     * @generated from protobuf field: int32 revision = 12
     */
    revision: number;
    /**
     * @generated from protobuf field: string hash_key = 13
     */
    hashKey: string;
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UnitType unit_type = 14
     */
    unitType: Experiment_UnitType;
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.Variation variations = 15
     */
    variations: Experiment_Variation[];
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.Rule rules = 16
     */
    rules: Experiment_Rule[];
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Phase phase = 18
     */
    phase: Experiment_Phase;
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.Surface surfaces = 19
     */
    surfaces: Experiment_Surface[];
    /**
     * @generated from protobuf field: string owning_team_id = 20
     */
    owningTeamId: string;
    /**
     * @generated from protobuf field: fixed64 cached_notification_channel_id = 21
     */
    cachedNotificationChannelId: bigint;
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ExposureTracking exposure_tracking = 22
     */
    exposureTracking: Experiment_ExposureTracking;
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.AssignmentMode assignment_mode = 25
     */
    assignmentMode: Experiment_AssignmentMode;
    /**
     * @generated from protobuf field: bool enable_edit_raw_json_ui = 23
     */
    enableEditRawJsonUi: boolean;
    /**
     * @generated from protobuf field: int32 winning_variation_id = 24
     */
    winningVariationId: number;
    /**
     * @generated from protobuf field: string extra_outcome_context = 34
     */
    extraOutcomeContext: string;
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Type type = 26
     */
    type: Experiment_Type;
    /**
     * @generated from protobuf field: bool is_template = 27
     */
    isTemplate: boolean;
    /**
     * @generated from protobuf field: repeated int32 field_numbers_to_copy = 28
     */
    fieldNumbersToCopy: number[];
    /**
     * @generated from protobuf field: repeated string engine_feature_flags = 29 [packed = false]
     */
    engineFeatureFlags: string[];
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.DebugConfig debug_config = 30
     */
    debugConfig?: Experiment_DebugConfig;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp expected_end_date = 31
     */
    expectedEndDate?: Timestamp;
    /**
     * @generated from protobuf field: bool is_automated_change = 32
     */
    isAutomatedChange: boolean;
    /**
     * @generated from protobuf field: optional google.protobuf.Timestamp archive_at = 33
     */
    archiveAt?: Timestamp;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Bucket
 */
export interface Experiment_Bucket {
    /**
     * @generated from protobuf field: int32 start = 1
     */
    start: number;
    /**
     * @generated from protobuf field: int32 stop = 2
     */
    stop: number;
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Type type = 3
     */
    type: Experiment_Type;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Variation
 */
export interface Experiment_Variation {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string label = 2
     */
    label: string;
    /**
     * @generated from protobuf field: int32 target_allocation = 3
     */
    targetAllocation: number;
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.Bucket buckets = 4
     */
    buckets: Experiment_Bucket[];
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Type type = 5
     */
    type: Experiment_Type;
    /**
     * @generated from protobuf field: optional google.protobuf.StringValue configuration = 6
     */
    configuration?: StringValue;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier
 */
export interface Experiment_PlatformVersionSpecifier {
    /**
     * @generated from protobuf field: uint32 major = 1
     */
    major: number;
    /**
     * @generated from protobuf field: optional google.protobuf.UInt32Value minor = 2
     */
    minor?: UInt32Value;
    /**
     * @generated from protobuf field: optional google.protobuf.UInt64Value build = 3
     */
    build?: UInt64Value;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound
 */
export interface Experiment_PlatformVersionRangeBound {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier version = 1
     */
    version?: Experiment_PlatformVersionSpecifier;
    /**
     * @generated from protobuf field: bool inclusive = 2
     */
    inclusive: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange
 */
export interface Experiment_PlatformVersionRange {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound lower_bound = 1
     */
    lowerBound?: Experiment_PlatformVersionRangeBound;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound upper_bound = 2
     */
    upperBound?: Experiment_PlatformVersionRangeBound;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersion
 */
export interface Experiment_PlatformVersion {
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange ranges = 1
     */
    ranges: Experiment_PlatformVersionRange[];
    /**
     * @generated from protobuf field: bool work_around_pyoto_bug = 2
     */
    workAroundPyotoBug: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientRequiredChanges
 */
export interface Experiment_ClientRequiredChanges {
    /**
     * @generated from protobuf field: repeated string commit_hashes = 1 [packed = false]
     */
    commitHashes: string[];
    /**
     * @generated from protobuf field: repeated int32 pr_numbers = 2
     */
    prNumbers: number[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientPlatform
 */
export interface Experiment_ClientPlatform {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion ios_version = 1
     */
    iosVersion?: Experiment_PlatformVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion android_version = 2
     */
    androidVersion?: Experiment_PlatformVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion web_version = 3
     */
    webVersion?: Experiment_PlatformVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion native_version = 4
     */
    nativeVersion?: Experiment_PlatformVersion;
    /**
     * @generated from protobuf field: bool allow_non_native_web = 6
     */
    allowNonNativeWeb: boolean;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.ClientRequiredChanges client_required_changes = 5
     */
    clientRequiredChanges?: Experiment_ClientRequiredChanges;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier
 */
export interface Experiment_SDKVersionSpecifier {
    /**
     * @generated from protobuf field: int32 version = 1
     */
    version: number;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound
 */
export interface Experiment_SDKVersionRangeBound {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier version = 1
     */
    version?: Experiment_SDKVersionSpecifier;
    /**
     * @generated from protobuf field: bool inclusive = 2
     */
    inclusive: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange
 */
export interface Experiment_SDKVersionRange {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound lower_bound = 1
     */
    lowerBound?: Experiment_SDKVersionRangeBound;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound upper_bound = 2
     */
    upperBound?: Experiment_SDKVersionRangeBound;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersion
 */
export interface Experiment_SDKVersion {
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange ranges = 1
     */
    ranges: Experiment_SDKVersionRange[];
    /**
     * @generated from protobuf field: bool work_around_pyoto_bug = 2
     */
    workAroundPyotoBug: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem
 */
export interface Experiment_ClientOperatingSystem {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion ios_version = 1
     */
    iosVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion android_version = 2
     */
    androidVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion macos_version = 3
     */
    macosVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion windows_version = 4
     */
    windowsVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion playstation_version = 5
     */
    playstationVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion xbox_version = 6
     */
    xboxVersion?: Experiment_SDKVersion;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion linux_version = 7
     */
    linuxVersion?: Experiment_SDKVersion;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.StaffUsers
 */
export interface Experiment_StaffUsers {
    /**
     * @generated from protobuf field: bool work_accounts = 1
     */
    workAccounts: boolean;
    /**
     * @generated from protobuf field: bool personal_accounts = 2
     */
    personalAccounts: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserInGuild
 */
export interface Experiment_UserInGuild {
    /**
     * @generated from protobuf field: repeated fixed64 guild_ids = 1
     */
    guildIds: bigint[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIds
 */
export interface Experiment_UserIds {
    /**
     * @generated from protobuf field: repeated fixed64 user_ids = 1
     */
    userIds: bigint[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientLocale
 */
export interface Experiment_ClientLocale {
    /**
     * @generated from protobuf field: repeated string locales = 1 [packed = false]
     */
    locales: string[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ISORegion
 */
export interface Experiment_ISORegion {
    /**
     * @generated from protobuf field: string iso_country = 1
     */
    isoCountry: string;
    /**
     * @generated from protobuf field: string iso_subdivision = 2
     */
    isoSubdivision: string;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Place
 */
export interface Experiment_Place {
    /**
     * @generated from protobuf field: string city = 1
     */
    city: string;
    /**
     * @generated from protobuf field: string subdivision = 2
     */
    subdivision: string;
    /**
     * @generated from protobuf field: string country = 3
     */
    country: string;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Location
 */
export interface Experiment_Location {
    /**
     * @generated from protobuf oneof: location
     */
    location: {
        oneofKind: "isoRegion";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ISORegion iso_region = 1
         */
        isoRegion: Experiment_ISORegion;
    } | {
        oneofKind: "isEu";
        /**
         * @generated from protobuf field: bool is_eu = 2
         */
        isEu: boolean;
    } | {
        oneofKind: "place";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Place place = 3
         */
        place: Experiment_Place;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientLocation
 */
export interface Experiment_ClientLocation {
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.Location locations = 1
     */
    locations: Experiment_Location[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientIP
 */
export interface Experiment_ClientIP {
    /**
     * @generated from protobuf field: repeated string blocks = 1 [packed = false]
     */
    blocks: string[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserLocale
 */
export interface Experiment_UserLocale {
    /**
     * @generated from protobuf field: repeated string locales = 1 [packed = false]
     */
    locales: string[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIsBot
 */
export interface Experiment_UserIsBot {
    /**
     * @generated from protobuf field: bool is_bot = 1
     */
    isBot: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserAgeRange
 */
export interface Experiment_UserAgeRange {
    /**
     * @generated from protobuf field: optional google.protobuf.UInt32Value min_age_years = 1
     */
    minAgeYears?: UInt32Value;
    /**
     * @generated from protobuf field: optional google.protobuf.UInt32Value max_age_years = 2
     */
    maxAgeYears?: UInt32Value;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Fixed64Value
 */
export interface Experiment_Fixed64Value {
    /**
     * @generated from protobuf field: fixed64 value = 1
     */
    value: bigint;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIDRange
 */
export interface Experiment_UserIDRange {
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value min_id = 1
     */
    minId?: Experiment_Fixed64Value;
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value max_id = 2
     */
    maxId?: Experiment_Fixed64Value;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserHasFlag
 */
export interface Experiment_UserHasFlag {
    /**
     * @generated from protobuf field: fixed64 mask = 1
     */
    mask: bigint;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash
 */
export interface Experiment_UnitIdInRangeByHash {
    /**
     * @generated from protobuf field: string hash_key = 1
     */
    hashKey: string;
    /**
     * @generated from protobuf field: uint32 stop_ring_position = 2
     */
    stopRingPosition: number;
    /**
     * @generated from protobuf field: uint32 start_ring_position = 3
     */
    startRingPosition: number;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel
 */
export interface Experiment_ClientReleaseChannel {
    /**
     * @generated from protobuf field: repeated string release_channels = 1 [packed = false]
     */
    releaseChannels: string[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Always
 */
export interface Experiment_Always {
    /**
     * @generated from protobuf field: bool value = 1
     */
    value: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientSystemLocale
 */
export interface Experiment_ClientSystemLocale {
    /**
     * @generated from protobuf field: repeated string locales = 1 [packed = false]
     */
    locales: string[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UnitIdInExperiment
 */
export interface Experiment_UnitIdInExperiment {
    /**
     * @generated from protobuf field: fixed64 experiment_id = 1
     */
    experimentId: bigint;
    /**
     * @generated from protobuf field: repeated int32 variation_ids = 2
     */
    variationIds: number[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UserPremiumType
 */
export interface Experiment_UserPremiumType {
    /**
     * @generated from protobuf field: repeated int32 premium_types = 1
     */
    premiumTypes: number[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.UnitIdMatchesFilterSnapshot
 */
export interface Experiment_UnitIdMatchesFilterSnapshot {
    /**
     * @generated from protobuf field: string filter_snapshot_name = 1
     */
    filterSnapshotName: string;
    /**
     * @generated from protobuf field: repeated fixed64 target_filter_values = 2
     */
    targetFilterValues: bigint[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.GuildIds
 */
export interface Experiment_GuildIds {
    /**
     * @generated from protobuf field: repeated fixed64 guild_ids = 1
     */
    guildIds: bigint[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.GuildMemberCountRange
 */
export interface Experiment_GuildMemberCountRange {
    /**
     * @generated from protobuf field: optional google.protobuf.UInt32Value min_count = 1
     */
    minCount?: UInt32Value;
    /**
     * @generated from protobuf field: optional google.protobuf.UInt32Value max_count = 2
     */
    maxCount?: UInt32Value;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.GuildHasFeature
 */
export interface Experiment_GuildHasFeature {
    /**
     * @generated from protobuf field: repeated string features = 1 [packed = false]
     */
    features: string[];
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Filter
 */
export interface Experiment_Filter {
    /**
     * @generated from protobuf oneof: filter
     */
    filter: {
        oneofKind: "clientVersion";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientPlatform client_version = 2
         */
        clientVersion: Experiment_ClientPlatform;
    } | {
        oneofKind: "clientOs";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem client_os = 3
         */
        clientOs: Experiment_ClientOperatingSystem;
    } | {
        oneofKind: "staff";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.StaffUsers staff = 4
         */
        staff: Experiment_StaffUsers;
    } | {
        oneofKind: "userInGuild";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserInGuild user_in_guild = 5
         */
        userInGuild: Experiment_UserInGuild;
    } | {
        oneofKind: "userIds";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserIds user_ids = 6
         */
        userIds: Experiment_UserIds;
    } | {
        oneofKind: "clientLocale";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientLocale client_locale = 7
         */
        clientLocale: Experiment_ClientLocale;
    } | {
        oneofKind: "clientLocation";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientLocation client_location = 8
         */
        clientLocation: Experiment_ClientLocation;
    } | {
        oneofKind: "clientIp";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientIP client_ip = 9
         */
        clientIp: Experiment_ClientIP;
    } | {
        oneofKind: "userLocale";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserLocale user_locale = 10
         */
        userLocale: Experiment_UserLocale;
    } | {
        oneofKind: "bot";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserIsBot bot = 11
         */
        bot: Experiment_UserIsBot;
    } | {
        oneofKind: "userAgeRange";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserAgeRange user_age_range = 12
         */
        userAgeRange: Experiment_UserAgeRange;
    } | {
        oneofKind: "userIdRange";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserIDRange user_id_range = 13
         */
        userIdRange: Experiment_UserIDRange;
    } | {
        oneofKind: "userHasFlag";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserHasFlag user_has_flag = 14
         */
        userHasFlag: Experiment_UserHasFlag;
    } | {
        oneofKind: "unitIdInRangeByHash";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash unit_id_in_range_by_hash = 15
         */
        unitIdInRangeByHash: Experiment_UnitIdInRangeByHash;
    } | {
        oneofKind: "clientReleaseChannel";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel client_release_channel = 16
         */
        clientReleaseChannel: Experiment_ClientReleaseChannel;
    } | {
        oneofKind: "always";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Always always = 17
         */
        always: Experiment_Always;
    } | {
        oneofKind: "clientSystemLocale";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.ClientSystemLocale client_system_locale = 18
         */
        clientSystemLocale: Experiment_ClientSystemLocale;
    } | {
        oneofKind: "unitIdInExperiment";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UnitIdInExperiment unit_id_in_experiment = 19
         */
        unitIdInExperiment: Experiment_UnitIdInExperiment;
    } | {
        oneofKind: "userPremiumType";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UserPremiumType user_premium_type = 20
         */
        userPremiumType: Experiment_UserPremiumType;
    } | {
        oneofKind: "unitIdMatchesFilterSnapshot";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.UnitIdMatchesFilterSnapshot unit_id_matches_filter_snapshot = 21
         */
        unitIdMatchesFilterSnapshot: Experiment_UnitIdMatchesFilterSnapshot;
    } | {
        oneofKind: "guildIds";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.GuildIds guild_ids = 22
         */
        guildIds: Experiment_GuildIds;
    } | {
        oneofKind: "guildMemberCountRange";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.GuildMemberCountRange guild_member_count_range = 25
         */
        guildMemberCountRange: Experiment_GuildMemberCountRange;
    } | {
        oneofKind: "guildHasFeature";
        /**
         * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.GuildHasFeature guild_has_feature = 26
         */
        guildHasFeature: Experiment_GuildHasFeature;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Override
 */
export interface Experiment_Override {
    /**
     * @generated from protobuf field: int32 variation_id = 1
     */
    variationId: number;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.Rule
 */
export interface Experiment_Rule {
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Type type = 1
     */
    type: Experiment_Type;
    /**
     * @generated from protobuf field: repeated discord_protos.discord_experimentation.v1.Experiment.Filter filters = 2
     */
    filters: Experiment_Filter[];
    /**
     * @generated from protobuf field: optional discord_protos.discord_experimentation.v1.Experiment.Override override = 3
     */
    override?: Experiment_Override;
    /**
     * @generated from protobuf field: bool is_sunset_rule = 4
     */
    isSunsetRule: boolean;
    /**
     * @generated from protobuf field: discord_protos.discord_experimentation.v1.Experiment.Subtype subtype = 5
     */
    subtype: Experiment_Subtype;
}
/**
 * @generated from protobuf message discord_protos.discord_experimentation.v1.Experiment.DebugConfig
 */
export interface Experiment_DebugConfig {
    /**
     * @generated from protobuf field: bool enable_decision_logging = 1
     */
    enableDecisionLogging: boolean;
    /**
     * @generated from protobuf field: double metrics_sample_rate = 2
     */
    metricsSampleRate: number;
    /**
     * @generated from protobuf field: bool log_context_on_failure = 3
     */
    logContextOnFailure: boolean;
    /**
     * @generated from protobuf field: bool log_raw_headers = 4
     */
    logRawHeaders: boolean;
    /**
     * @generated from protobuf field: bool tag_filter_metrics = 5
     */
    tagFilterMetrics: boolean;
    /**
     * @generated from protobuf field: double decision_log_sample_rate = 6
     */
    decisionLogSampleRate: number;
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.UnitType
 */
export enum Experiment_UnitType {
    /**
     * @generated from protobuf enum value: UNIT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: UNIT_TYPE_USER = 1;
     */
    USER = 1,
    /**
     * @generated from protobuf enum value: UNIT_TYPE_INSTALLATION = 2;
     */
    INSTALLATION = 2,
    /**
     * @generated from protobuf enum value: UNIT_TYPE_GUILD = 3;
     */
    GUILD = 3
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.Type
 */
export enum Experiment_Type {
    /**
     * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TYPE_ACTIVE = 1;
     */
    ACTIVE = 1,
    /**
     * @generated from protobuf enum value: TYPE_UNUSED = 2;
     */
    UNUSED = 2,
    /**
     * @generated from protobuf enum value: TYPE_BURNED = 3;
     */
    BURNED = 3,
    /**
     * @generated from protobuf enum value: TYPE_PRESERVED = 4;
     */
    PRESERVED = 4
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.Subtype
 */
export enum Experiment_Subtype {
    /**
     * @generated from protobuf enum value: SUBTYPE_REGULAR = 0;
     */
    REGULAR = 0,
    /**
     * @generated from protobuf enum value: SUBTYPE_HOLDOUT = 1;
     */
    HOLDOUT = 1
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.Phase
 */
export enum Experiment_Phase {
    /**
     * @generated from protobuf enum value: PHASE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PHASE_DRAFT = 1;
     */
    DRAFT = 1,
    /**
     * @generated from protobuf enum value: PHASE_MEASUREMENT = 2;
     */
    MEASUREMENT = 2,
    /**
     * @generated from protobuf enum value: PHASE_ROLLING_OUT = 4;
     */
    ROLLING_OUT = 4,
    /**
     * @generated from protobuf enum value: PHASE_ARCHIVED = 6;
     */
    ARCHIVED = 6,
    /**
     * @generated from protobuf enum value: PHASE_AA_MODE = 7;
     */
    AA_MODE = 7
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.Surface
 */
export enum Experiment_Surface {
    /**
     * @generated from protobuf enum value: SURFACE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SURFACE_API = 1;
     */
    API = 1,
    /**
     * @generated from protobuf enum value: SURFACE_APP = 2;
     */
    APP = 2,
    /**
     * @generated from protobuf enum value: SURFACE_DEVELOPER_PORTAL = 3;
     */
    DEVELOPER_PORTAL = 3,
    /**
     * @generated from protobuf enum value: SURFACE_ADMIN_PANEL = 4;
     */
    ADMIN_PANEL = 4,
    /**
     * @generated from protobuf enum value: SURFACE_ADS_BUDGET_AB = 5;
     */
    ADS_BUDGET_AB = 5
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.ExposureTracking
 */
export enum Experiment_ExposureTracking {
    /**
     * @generated from protobuf enum value: EXPOSURE_TRACKING_ENABLED = 0;
     */
    ENABLED = 0,
    /**
     * @generated from protobuf enum value: EXPOSURE_TRACKING_DISABLED = 1;
     */
    DISABLED = 1
}
/**
 * @generated from protobuf enum discord_protos.discord_experimentation.v1.Experiment.AssignmentMode
 */
export enum Experiment_AssignmentMode {
    /**
     * @generated from protobuf enum value: ASSIGNMENT_MODE_FULL = 0;
     */
    FULL = 0,
    /**
     * @generated from protobuf enum value: ASSIGNMENT_MODE_FORCE_CONTROL = 3;
     */
    FORCE_CONTROL = 3,
    /**
     * @generated from protobuf enum value: ASSIGNMENT_MODE_OVERRIDES_ONLY = 4;
     */
    OVERRIDES_ONLY = 4,
    /**
     * @generated from protobuf enum value: ASSIGNMENT_MODE_OFF = 5;
     */
    OFF = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class Experiment$Type extends MessageType<Experiment> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment", [
            { no: 1, name: "id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 4, name: "creator_id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "version", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "edited_at", kind: "message", T: () => Timestamp },
            { no: 7, name: "editor_id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "hypothesis", kind: "message", T: () => StringValue },
            { no: 11, name: "tech_spec_link", kind: "message", T: () => StringValue },
            { no: 12, name: "revision", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "hash_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "unit_type", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.UnitType", Experiment_UnitType, "UNIT_TYPE_"] },
            { no: 15, name: "variations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_Variation },
            { no: 16, name: "rules", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_Rule },
            { no: 18, name: "phase", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.Phase", Experiment_Phase, "PHASE_"] },
            { no: 19, name: "surfaces", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["discord_protos.discord_experimentation.v1.Experiment.Surface", Experiment_Surface, "SURFACE_"] },
            { no: 20, name: "owning_team_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "cached_notification_channel_id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 22, name: "exposure_tracking", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.ExposureTracking", Experiment_ExposureTracking, "EXPOSURE_TRACKING_"] },
            { no: 25, name: "assignment_mode", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.AssignmentMode", Experiment_AssignmentMode, "ASSIGNMENT_MODE_"] },
            { no: 23, name: "enable_edit_raw_json_ui", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "winning_variation_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 34, name: "extra_outcome_context", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "type", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.Type", Experiment_Type, "TYPE_"] },
            { no: 27, name: "is_template", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 28, name: "field_numbers_to_copy", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 29, name: "engine_feature_flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "debug_config", kind: "message", T: () => Experiment_DebugConfig },
            { no: 31, name: "expected_end_date", kind: "message", T: () => Timestamp },
            { no: 32, name: "is_automated_change", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 33, name: "archive_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Experiment>): Experiment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.name = "";
        message.creatorId = 0n;
        message.version = 0;
        message.editorId = 0n;
        message.title = "";
        message.description = "";
        message.revision = 0;
        message.hashKey = "";
        message.unitType = 0;
        message.variations = [];
        message.rules = [];
        message.phase = 0;
        message.surfaces = [];
        message.owningTeamId = "";
        message.cachedNotificationChannelId = 0n;
        message.exposureTracking = 0;
        message.assignmentMode = 0;
        message.enableEditRawJsonUi = false;
        message.winningVariationId = 0;
        message.extraOutcomeContext = "";
        message.type = 0;
        message.isTemplate = false;
        message.fieldNumbersToCopy = [];
        message.engineFeatureFlags = [];
        message.isAutomatedChange = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment): Experiment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed64 id */ 1:
                    message.id = reader.fixed64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional google.protobuf.Timestamp created_at */ 3:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* fixed64 creator_id */ 4:
                    message.creatorId = reader.fixed64().toBigInt();
                    break;
                case /* int32 version */ 5:
                    message.version = reader.int32();
                    break;
                case /* optional google.protobuf.Timestamp edited_at */ 6:
                    message.editedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.editedAt);
                    break;
                case /* fixed64 editor_id */ 7:
                    message.editorId = reader.fixed64().toBigInt();
                    break;
                case /* string title */ 8:
                    message.title = reader.string();
                    break;
                case /* string description */ 9:
                    message.description = reader.string();
                    break;
                case /* optional google.protobuf.StringValue hypothesis */ 10:
                    message.hypothesis = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.hypothesis);
                    break;
                case /* optional google.protobuf.StringValue tech_spec_link */ 11:
                    message.techSpecLink = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.techSpecLink);
                    break;
                case /* int32 revision */ 12:
                    message.revision = reader.int32();
                    break;
                case /* string hash_key */ 13:
                    message.hashKey = reader.string();
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UnitType unit_type */ 14:
                    message.unitType = reader.int32();
                    break;
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.Variation variations */ 15:
                    message.variations.push(Experiment_Variation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.Rule rules */ 16:
                    message.rules.push(Experiment_Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Phase phase */ 18:
                    message.phase = reader.int32();
                    break;
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.Surface surfaces */ 19:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.surfaces.push(reader.int32());
                    else
                        message.surfaces.push(reader.int32());
                    break;
                case /* string owning_team_id */ 20:
                    message.owningTeamId = reader.string();
                    break;
                case /* fixed64 cached_notification_channel_id */ 21:
                    message.cachedNotificationChannelId = reader.fixed64().toBigInt();
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ExposureTracking exposure_tracking */ 22:
                    message.exposureTracking = reader.int32();
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.AssignmentMode assignment_mode */ 25:
                    message.assignmentMode = reader.int32();
                    break;
                case /* bool enable_edit_raw_json_ui */ 23:
                    message.enableEditRawJsonUi = reader.bool();
                    break;
                case /* int32 winning_variation_id */ 24:
                    message.winningVariationId = reader.int32();
                    break;
                case /* string extra_outcome_context */ 34:
                    message.extraOutcomeContext = reader.string();
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Type type */ 26:
                    message.type = reader.int32();
                    break;
                case /* bool is_template */ 27:
                    message.isTemplate = reader.bool();
                    break;
                case /* repeated int32 field_numbers_to_copy */ 28:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fieldNumbersToCopy.push(reader.int32());
                    else
                        message.fieldNumbersToCopy.push(reader.int32());
                    break;
                case /* repeated string engine_feature_flags = 29 [packed = false] */ 29:
                    message.engineFeatureFlags.push(reader.string());
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.DebugConfig debug_config */ 30:
                    message.debugConfig = Experiment_DebugConfig.internalBinaryRead(reader, reader.uint32(), options, message.debugConfig);
                    break;
                case /* optional google.protobuf.Timestamp expected_end_date */ 31:
                    message.expectedEndDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expectedEndDate);
                    break;
                case /* bool is_automated_change */ 32:
                    message.isAutomatedChange = reader.bool();
                    break;
                case /* optional google.protobuf.Timestamp archive_at */ 33:
                    message.archiveAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.archiveAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Bit64).fixed64(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional google.protobuf.Timestamp created_at = 3; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* fixed64 creator_id = 4; */
        if (message.creatorId !== 0n)
            writer.tag(4, WireType.Bit64).fixed64(message.creatorId);
        /* int32 version = 5; */
        if (message.version !== 0)
            writer.tag(5, WireType.Varint).int32(message.version);
        /* optional google.protobuf.Timestamp edited_at = 6; */
        if (message.editedAt)
            Timestamp.internalBinaryWrite(message.editedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* fixed64 editor_id = 7; */
        if (message.editorId !== 0n)
            writer.tag(7, WireType.Bit64).fixed64(message.editorId);
        /* string title = 8; */
        if (message.title !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.title);
        /* string description = 9; */
        if (message.description !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.description);
        /* optional google.protobuf.StringValue hypothesis = 10; */
        if (message.hypothesis)
            StringValue.internalBinaryWrite(message.hypothesis, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.StringValue tech_spec_link = 11; */
        if (message.techSpecLink)
            StringValue.internalBinaryWrite(message.techSpecLink, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* int32 revision = 12; */
        if (message.revision !== 0)
            writer.tag(12, WireType.Varint).int32(message.revision);
        /* string hash_key = 13; */
        if (message.hashKey !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.hashKey);
        /* discord_protos.discord_experimentation.v1.Experiment.UnitType unit_type = 14; */
        if (message.unitType !== 0)
            writer.tag(14, WireType.Varint).int32(message.unitType);
        /* repeated discord_protos.discord_experimentation.v1.Experiment.Variation variations = 15; */
        for (let i = 0; i < message.variations.length; i++)
            Experiment_Variation.internalBinaryWrite(message.variations[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated discord_protos.discord_experimentation.v1.Experiment.Rule rules = 16; */
        for (let i = 0; i < message.rules.length; i++)
            Experiment_Rule.internalBinaryWrite(message.rules[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.Phase phase = 18; */
        if (message.phase !== 0)
            writer.tag(18, WireType.Varint).int32(message.phase);
        /* repeated discord_protos.discord_experimentation.v1.Experiment.Surface surfaces = 19; */
        if (message.surfaces.length) {
            writer.tag(19, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.surfaces.length; i++)
                writer.int32(message.surfaces[i]);
            writer.join();
        }
        /* string owning_team_id = 20; */
        if (message.owningTeamId !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.owningTeamId);
        /* fixed64 cached_notification_channel_id = 21; */
        if (message.cachedNotificationChannelId !== 0n)
            writer.tag(21, WireType.Bit64).fixed64(message.cachedNotificationChannelId);
        /* discord_protos.discord_experimentation.v1.Experiment.ExposureTracking exposure_tracking = 22; */
        if (message.exposureTracking !== 0)
            writer.tag(22, WireType.Varint).int32(message.exposureTracking);
        /* bool enable_edit_raw_json_ui = 23; */
        if (message.enableEditRawJsonUi !== false)
            writer.tag(23, WireType.Varint).bool(message.enableEditRawJsonUi);
        /* int32 winning_variation_id = 24; */
        if (message.winningVariationId !== 0)
            writer.tag(24, WireType.Varint).int32(message.winningVariationId);
        /* discord_protos.discord_experimentation.v1.Experiment.AssignmentMode assignment_mode = 25; */
        if (message.assignmentMode !== 0)
            writer.tag(25, WireType.Varint).int32(message.assignmentMode);
        /* discord_protos.discord_experimentation.v1.Experiment.Type type = 26; */
        if (message.type !== 0)
            writer.tag(26, WireType.Varint).int32(message.type);
        /* bool is_template = 27; */
        if (message.isTemplate !== false)
            writer.tag(27, WireType.Varint).bool(message.isTemplate);
        /* repeated int32 field_numbers_to_copy = 28; */
        if (message.fieldNumbersToCopy.length) {
            writer.tag(28, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.fieldNumbersToCopy.length; i++)
                writer.int32(message.fieldNumbersToCopy[i]);
            writer.join();
        }
        /* repeated string engine_feature_flags = 29 [packed = false]; */
        for (let i = 0; i < message.engineFeatureFlags.length; i++)
            writer.tag(29, WireType.LengthDelimited).string(message.engineFeatureFlags[i]);
        /* optional discord_protos.discord_experimentation.v1.Experiment.DebugConfig debug_config = 30; */
        if (message.debugConfig)
            Experiment_DebugConfig.internalBinaryWrite(message.debugConfig, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.Timestamp expected_end_date = 31; */
        if (message.expectedEndDate)
            Timestamp.internalBinaryWrite(message.expectedEndDate, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* bool is_automated_change = 32; */
        if (message.isAutomatedChange !== false)
            writer.tag(32, WireType.Varint).bool(message.isAutomatedChange);
        /* optional google.protobuf.Timestamp archive_at = 33; */
        if (message.archiveAt)
            Timestamp.internalBinaryWrite(message.archiveAt, writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* string extra_outcome_context = 34; */
        if (message.extraOutcomeContext !== "")
            writer.tag(34, WireType.LengthDelimited).string(message.extraOutcomeContext);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment
 */
export const Experiment = new Experiment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Bucket$Type extends MessageType<Experiment_Bucket> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Bucket", [
            { no: 1, name: "start", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "stop", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "type", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.Type", Experiment_Type, "TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<Experiment_Bucket>): Experiment_Bucket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.start = 0;
        message.stop = 0;
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_Bucket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Bucket): Experiment_Bucket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 start */ 1:
                    message.start = reader.int32();
                    break;
                case /* int32 stop */ 2:
                    message.stop = reader.int32();
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Type type */ 3:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Bucket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 start = 1; */
        if (message.start !== 0)
            writer.tag(1, WireType.Varint).int32(message.start);
        /* int32 stop = 2; */
        if (message.stop !== 0)
            writer.tag(2, WireType.Varint).int32(message.stop);
        /* discord_protos.discord_experimentation.v1.Experiment.Type type = 3; */
        if (message.type !== 0)
            writer.tag(3, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Bucket
 */
export const Experiment_Bucket = new Experiment_Bucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Variation$Type extends MessageType<Experiment_Variation> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Variation", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "target_allocation", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "buckets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_Bucket },
            { no: 5, name: "type", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.Type", Experiment_Type, "TYPE_"] },
            { no: 6, name: "configuration", kind: "message", T: () => StringValue }
        ]);
    }
    create(value?: PartialMessage<Experiment_Variation>): Experiment_Variation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.label = "";
        message.targetAllocation = 0;
        message.buckets = [];
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_Variation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Variation): Experiment_Variation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* int32 target_allocation */ 3:
                    message.targetAllocation = reader.int32();
                    break;
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.Bucket buckets */ 4:
                    message.buckets.push(Experiment_Bucket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Type type */ 5:
                    message.type = reader.int32();
                    break;
                case /* optional google.protobuf.StringValue configuration */ 6:
                    message.configuration = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.configuration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Variation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* int32 target_allocation = 3; */
        if (message.targetAllocation !== 0)
            writer.tag(3, WireType.Varint).int32(message.targetAllocation);
        /* repeated discord_protos.discord_experimentation.v1.Experiment.Bucket buckets = 4; */
        for (let i = 0; i < message.buckets.length; i++)
            Experiment_Bucket.internalBinaryWrite(message.buckets[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.Type type = 5; */
        if (message.type !== 0)
            writer.tag(5, WireType.Varint).int32(message.type);
        /* optional google.protobuf.StringValue configuration = 6; */
        if (message.configuration)
            StringValue.internalBinaryWrite(message.configuration, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Variation
 */
export const Experiment_Variation = new Experiment_Variation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_PlatformVersionSpecifier$Type extends MessageType<Experiment_PlatformVersionSpecifier> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier", [
            { no: 1, name: "major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "minor", kind: "message", T: () => UInt32Value },
            { no: 3, name: "build", kind: "message", T: () => UInt64Value }
        ]);
    }
    create(value?: PartialMessage<Experiment_PlatformVersionSpecifier>): Experiment_PlatformVersionSpecifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.major = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_PlatformVersionSpecifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_PlatformVersionSpecifier): Experiment_PlatformVersionSpecifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 major */ 1:
                    message.major = reader.uint32();
                    break;
                case /* optional google.protobuf.UInt32Value minor */ 2:
                    message.minor = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.minor);
                    break;
                case /* optional google.protobuf.UInt64Value build */ 3:
                    message.build = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.build);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_PlatformVersionSpecifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 major = 1; */
        if (message.major !== 0)
            writer.tag(1, WireType.Varint).uint32(message.major);
        /* optional google.protobuf.UInt32Value minor = 2; */
        if (message.minor)
            UInt32Value.internalBinaryWrite(message.minor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.UInt64Value build = 3; */
        if (message.build)
            UInt64Value.internalBinaryWrite(message.build, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier
 */
export const Experiment_PlatformVersionSpecifier = new Experiment_PlatformVersionSpecifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_PlatformVersionRangeBound$Type extends MessageType<Experiment_PlatformVersionRangeBound> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound", [
            { no: 1, name: "version", kind: "message", T: () => Experiment_PlatformVersionSpecifier },
            { no: 2, name: "inclusive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_PlatformVersionRangeBound>): Experiment_PlatformVersionRangeBound {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inclusive = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_PlatformVersionRangeBound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_PlatformVersionRangeBound): Experiment_PlatformVersionRangeBound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier version */ 1:
                    message.version = Experiment_PlatformVersionSpecifier.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* bool inclusive */ 2:
                    message.inclusive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_PlatformVersionRangeBound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionSpecifier version = 1; */
        if (message.version)
            Experiment_PlatformVersionSpecifier.internalBinaryWrite(message.version, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool inclusive = 2; */
        if (message.inclusive !== false)
            writer.tag(2, WireType.Varint).bool(message.inclusive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound
 */
export const Experiment_PlatformVersionRangeBound = new Experiment_PlatformVersionRangeBound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_PlatformVersionRange$Type extends MessageType<Experiment_PlatformVersionRange> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange", [
            { no: 1, name: "lower_bound", kind: "message", T: () => Experiment_PlatformVersionRangeBound },
            { no: 2, name: "upper_bound", kind: "message", T: () => Experiment_PlatformVersionRangeBound }
        ]);
    }
    create(value?: PartialMessage<Experiment_PlatformVersionRange>): Experiment_PlatformVersionRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_PlatformVersionRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_PlatformVersionRange): Experiment_PlatformVersionRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound lower_bound */ 1:
                    message.lowerBound = Experiment_PlatformVersionRangeBound.internalBinaryRead(reader, reader.uint32(), options, message.lowerBound);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound upper_bound */ 2:
                    message.upperBound = Experiment_PlatformVersionRangeBound.internalBinaryRead(reader, reader.uint32(), options, message.upperBound);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_PlatformVersionRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound lower_bound = 1; */
        if (message.lowerBound)
            Experiment_PlatformVersionRangeBound.internalBinaryWrite(message.lowerBound, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRangeBound upper_bound = 2; */
        if (message.upperBound)
            Experiment_PlatformVersionRangeBound.internalBinaryWrite(message.upperBound, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange
 */
export const Experiment_PlatformVersionRange = new Experiment_PlatformVersionRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_PlatformVersion$Type extends MessageType<Experiment_PlatformVersion> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.PlatformVersion", [
            { no: 1, name: "ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_PlatformVersionRange },
            { no: 2, name: "work_around_pyoto_bug", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_PlatformVersion>): Experiment_PlatformVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ranges = [];
        message.workAroundPyotoBug = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_PlatformVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_PlatformVersion): Experiment_PlatformVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange ranges */ 1:
                    message.ranges.push(Experiment_PlatformVersionRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool work_around_pyoto_bug */ 2:
                    message.workAroundPyotoBug = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_PlatformVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated discord_protos.discord_experimentation.v1.Experiment.PlatformVersionRange ranges = 1; */
        for (let i = 0; i < message.ranges.length; i++)
            Experiment_PlatformVersionRange.internalBinaryWrite(message.ranges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool work_around_pyoto_bug = 2; */
        if (message.workAroundPyotoBug !== false)
            writer.tag(2, WireType.Varint).bool(message.workAroundPyotoBug);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.PlatformVersion
 */
export const Experiment_PlatformVersion = new Experiment_PlatformVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientRequiredChanges$Type extends MessageType<Experiment_ClientRequiredChanges> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientRequiredChanges", [
            { no: 1, name: "commit_hashes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pr_numbers", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientRequiredChanges>): Experiment_ClientRequiredChanges {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.commitHashes = [];
        message.prNumbers = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientRequiredChanges>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientRequiredChanges): Experiment_ClientRequiredChanges {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string commit_hashes = 1 [packed = false] */ 1:
                    message.commitHashes.push(reader.string());
                    break;
                case /* repeated int32 pr_numbers */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.prNumbers.push(reader.int32());
                    else
                        message.prNumbers.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientRequiredChanges, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string commit_hashes = 1 [packed = false]; */
        for (let i = 0; i < message.commitHashes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.commitHashes[i]);
        /* repeated int32 pr_numbers = 2; */
        if (message.prNumbers.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.prNumbers.length; i++)
                writer.int32(message.prNumbers[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientRequiredChanges
 */
export const Experiment_ClientRequiredChanges = new Experiment_ClientRequiredChanges$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientPlatform$Type extends MessageType<Experiment_ClientPlatform> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientPlatform", [
            { no: 1, name: "ios_version", kind: "message", T: () => Experiment_PlatformVersion },
            { no: 2, name: "android_version", kind: "message", T: () => Experiment_PlatformVersion },
            { no: 3, name: "web_version", kind: "message", T: () => Experiment_PlatformVersion },
            { no: 4, name: "native_version", kind: "message", T: () => Experiment_PlatformVersion },
            { no: 6, name: "allow_non_native_web", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "client_required_changes", kind: "message", T: () => Experiment_ClientRequiredChanges }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientPlatform>): Experiment_ClientPlatform {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowNonNativeWeb = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientPlatform>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientPlatform): Experiment_ClientPlatform {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion ios_version */ 1:
                    message.iosVersion = Experiment_PlatformVersion.internalBinaryRead(reader, reader.uint32(), options, message.iosVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion android_version */ 2:
                    message.androidVersion = Experiment_PlatformVersion.internalBinaryRead(reader, reader.uint32(), options, message.androidVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion web_version */ 3:
                    message.webVersion = Experiment_PlatformVersion.internalBinaryRead(reader, reader.uint32(), options, message.webVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion native_version */ 4:
                    message.nativeVersion = Experiment_PlatformVersion.internalBinaryRead(reader, reader.uint32(), options, message.nativeVersion);
                    break;
                case /* bool allow_non_native_web */ 6:
                    message.allowNonNativeWeb = reader.bool();
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.ClientRequiredChanges client_required_changes */ 5:
                    message.clientRequiredChanges = Experiment_ClientRequiredChanges.internalBinaryRead(reader, reader.uint32(), options, message.clientRequiredChanges);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientPlatform, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion ios_version = 1; */
        if (message.iosVersion)
            Experiment_PlatformVersion.internalBinaryWrite(message.iosVersion, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion android_version = 2; */
        if (message.androidVersion)
            Experiment_PlatformVersion.internalBinaryWrite(message.androidVersion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion web_version = 3; */
        if (message.webVersion)
            Experiment_PlatformVersion.internalBinaryWrite(message.webVersion, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.PlatformVersion native_version = 4; */
        if (message.nativeVersion)
            Experiment_PlatformVersion.internalBinaryWrite(message.nativeVersion, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.ClientRequiredChanges client_required_changes = 5; */
        if (message.clientRequiredChanges)
            Experiment_ClientRequiredChanges.internalBinaryWrite(message.clientRequiredChanges, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool allow_non_native_web = 6; */
        if (message.allowNonNativeWeb !== false)
            writer.tag(6, WireType.Varint).bool(message.allowNonNativeWeb);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientPlatform
 */
export const Experiment_ClientPlatform = new Experiment_ClientPlatform$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_SDKVersionSpecifier$Type extends MessageType<Experiment_SDKVersionSpecifier> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier", [
            { no: 1, name: "version", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_SDKVersionSpecifier>): Experiment_SDKVersionSpecifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_SDKVersionSpecifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_SDKVersionSpecifier): Experiment_SDKVersionSpecifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 version */ 1:
                    message.version = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_SDKVersionSpecifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 version = 1; */
        if (message.version !== 0)
            writer.tag(1, WireType.Varint).int32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier
 */
export const Experiment_SDKVersionSpecifier = new Experiment_SDKVersionSpecifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_SDKVersionRangeBound$Type extends MessageType<Experiment_SDKVersionRangeBound> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound", [
            { no: 1, name: "version", kind: "message", T: () => Experiment_SDKVersionSpecifier },
            { no: 2, name: "inclusive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_SDKVersionRangeBound>): Experiment_SDKVersionRangeBound {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inclusive = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_SDKVersionRangeBound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_SDKVersionRangeBound): Experiment_SDKVersionRangeBound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier version */ 1:
                    message.version = Experiment_SDKVersionSpecifier.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* bool inclusive */ 2:
                    message.inclusive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_SDKVersionRangeBound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionSpecifier version = 1; */
        if (message.version)
            Experiment_SDKVersionSpecifier.internalBinaryWrite(message.version, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool inclusive = 2; */
        if (message.inclusive !== false)
            writer.tag(2, WireType.Varint).bool(message.inclusive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound
 */
export const Experiment_SDKVersionRangeBound = new Experiment_SDKVersionRangeBound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_SDKVersionRange$Type extends MessageType<Experiment_SDKVersionRange> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange", [
            { no: 1, name: "lower_bound", kind: "message", T: () => Experiment_SDKVersionRangeBound },
            { no: 2, name: "upper_bound", kind: "message", T: () => Experiment_SDKVersionRangeBound }
        ]);
    }
    create(value?: PartialMessage<Experiment_SDKVersionRange>): Experiment_SDKVersionRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_SDKVersionRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_SDKVersionRange): Experiment_SDKVersionRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound lower_bound */ 1:
                    message.lowerBound = Experiment_SDKVersionRangeBound.internalBinaryRead(reader, reader.uint32(), options, message.lowerBound);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound upper_bound */ 2:
                    message.upperBound = Experiment_SDKVersionRangeBound.internalBinaryRead(reader, reader.uint32(), options, message.upperBound);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_SDKVersionRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound lower_bound = 1; */
        if (message.lowerBound)
            Experiment_SDKVersionRangeBound.internalBinaryWrite(message.lowerBound, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersionRangeBound upper_bound = 2; */
        if (message.upperBound)
            Experiment_SDKVersionRangeBound.internalBinaryWrite(message.upperBound, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange
 */
export const Experiment_SDKVersionRange = new Experiment_SDKVersionRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_SDKVersion$Type extends MessageType<Experiment_SDKVersion> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.SDKVersion", [
            { no: 1, name: "ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_SDKVersionRange },
            { no: 2, name: "work_around_pyoto_bug", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_SDKVersion>): Experiment_SDKVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ranges = [];
        message.workAroundPyotoBug = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_SDKVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_SDKVersion): Experiment_SDKVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange ranges */ 1:
                    message.ranges.push(Experiment_SDKVersionRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool work_around_pyoto_bug */ 2:
                    message.workAroundPyotoBug = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_SDKVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated discord_protos.discord_experimentation.v1.Experiment.SDKVersionRange ranges = 1; */
        for (let i = 0; i < message.ranges.length; i++)
            Experiment_SDKVersionRange.internalBinaryWrite(message.ranges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool work_around_pyoto_bug = 2; */
        if (message.workAroundPyotoBug !== false)
            writer.tag(2, WireType.Varint).bool(message.workAroundPyotoBug);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.SDKVersion
 */
export const Experiment_SDKVersion = new Experiment_SDKVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientOperatingSystem$Type extends MessageType<Experiment_ClientOperatingSystem> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem", [
            { no: 1, name: "ios_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 2, name: "android_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 3, name: "macos_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 4, name: "windows_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 5, name: "playstation_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 6, name: "xbox_version", kind: "message", T: () => Experiment_SDKVersion },
            { no: 7, name: "linux_version", kind: "message", T: () => Experiment_SDKVersion }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientOperatingSystem>): Experiment_ClientOperatingSystem {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientOperatingSystem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientOperatingSystem): Experiment_ClientOperatingSystem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion ios_version */ 1:
                    message.iosVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.iosVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion android_version */ 2:
                    message.androidVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.androidVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion macos_version */ 3:
                    message.macosVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.macosVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion windows_version */ 4:
                    message.windowsVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.windowsVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion playstation_version */ 5:
                    message.playstationVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.playstationVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion xbox_version */ 6:
                    message.xboxVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.xboxVersion);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion linux_version */ 7:
                    message.linuxVersion = Experiment_SDKVersion.internalBinaryRead(reader, reader.uint32(), options, message.linuxVersion);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientOperatingSystem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion ios_version = 1; */
        if (message.iosVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.iosVersion, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion android_version = 2; */
        if (message.androidVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.androidVersion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion macos_version = 3; */
        if (message.macosVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.macosVersion, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion windows_version = 4; */
        if (message.windowsVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.windowsVersion, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion playstation_version = 5; */
        if (message.playstationVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.playstationVersion, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion xbox_version = 6; */
        if (message.xboxVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.xboxVersion, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.SDKVersion linux_version = 7; */
        if (message.linuxVersion)
            Experiment_SDKVersion.internalBinaryWrite(message.linuxVersion, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem
 */
export const Experiment_ClientOperatingSystem = new Experiment_ClientOperatingSystem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_StaffUsers$Type extends MessageType<Experiment_StaffUsers> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.StaffUsers", [
            { no: 1, name: "work_accounts", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "personal_accounts", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_StaffUsers>): Experiment_StaffUsers {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workAccounts = false;
        message.personalAccounts = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_StaffUsers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_StaffUsers): Experiment_StaffUsers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool work_accounts */ 1:
                    message.workAccounts = reader.bool();
                    break;
                case /* bool personal_accounts */ 2:
                    message.personalAccounts = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_StaffUsers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool work_accounts = 1; */
        if (message.workAccounts !== false)
            writer.tag(1, WireType.Varint).bool(message.workAccounts);
        /* bool personal_accounts = 2; */
        if (message.personalAccounts !== false)
            writer.tag(2, WireType.Varint).bool(message.personalAccounts);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.StaffUsers
 */
export const Experiment_StaffUsers = new Experiment_StaffUsers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserInGuild$Type extends MessageType<Experiment_UserInGuild> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserInGuild", [
            { no: 1, name: "guild_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserInGuild>): Experiment_UserInGuild {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.guildIds = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserInGuild>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserInGuild): Experiment_UserInGuild {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 guild_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.guildIds.push(reader.fixed64().toBigInt());
                    else
                        message.guildIds.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserInGuild, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 guild_ids = 1; */
        if (message.guildIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.guildIds.length; i++)
                writer.fixed64(message.guildIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserInGuild
 */
export const Experiment_UserInGuild = new Experiment_UserInGuild$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserIds$Type extends MessageType<Experiment_UserIds> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserIds", [
            { no: 1, name: "user_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserIds>): Experiment_UserIds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userIds = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserIds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserIds): Experiment_UserIds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 user_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.userIds.push(reader.fixed64().toBigInt());
                    else
                        message.userIds.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserIds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 user_ids = 1; */
        if (message.userIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.userIds.length; i++)
                writer.fixed64(message.userIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIds
 */
export const Experiment_UserIds = new Experiment_UserIds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientLocale$Type extends MessageType<Experiment_ClientLocale> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientLocale", [
            { no: 1, name: "locales", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientLocale>): Experiment_ClientLocale {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locales = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientLocale>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientLocale): Experiment_ClientLocale {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string locales = 1 [packed = false] */ 1:
                    message.locales.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientLocale, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string locales = 1 [packed = false]; */
        for (let i = 0; i < message.locales.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.locales[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientLocale
 */
export const Experiment_ClientLocale = new Experiment_ClientLocale$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ISORegion$Type extends MessageType<Experiment_ISORegion> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ISORegion", [
            { no: 1, name: "iso_country", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "iso_subdivision", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_ISORegion>): Experiment_ISORegion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isoCountry = "";
        message.isoSubdivision = "";
        if (value !== undefined)
            reflectionMergePartial<Experiment_ISORegion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ISORegion): Experiment_ISORegion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string iso_country */ 1:
                    message.isoCountry = reader.string();
                    break;
                case /* string iso_subdivision */ 2:
                    message.isoSubdivision = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ISORegion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string iso_country = 1; */
        if (message.isoCountry !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.isoCountry);
        /* string iso_subdivision = 2; */
        if (message.isoSubdivision !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.isoSubdivision);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ISORegion
 */
export const Experiment_ISORegion = new Experiment_ISORegion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Place$Type extends MessageType<Experiment_Place> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Place", [
            { no: 1, name: "city", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subdivision", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "country", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_Place>): Experiment_Place {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.city = "";
        message.subdivision = "";
        message.country = "";
        if (value !== undefined)
            reflectionMergePartial<Experiment_Place>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Place): Experiment_Place {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string city */ 1:
                    message.city = reader.string();
                    break;
                case /* string subdivision */ 2:
                    message.subdivision = reader.string();
                    break;
                case /* string country */ 3:
                    message.country = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Place, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string city = 1; */
        if (message.city !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.city);
        /* string subdivision = 2; */
        if (message.subdivision !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subdivision);
        /* string country = 3; */
        if (message.country !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.country);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Place
 */
export const Experiment_Place = new Experiment_Place$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Location$Type extends MessageType<Experiment_Location> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Location", [
            { no: 1, name: "iso_region", kind: "message", oneof: "location", T: () => Experiment_ISORegion },
            { no: 2, name: "is_eu", kind: "scalar", oneof: "location", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "place", kind: "message", oneof: "location", T: () => Experiment_Place }
        ]);
    }
    create(value?: PartialMessage<Experiment_Location>): Experiment_Location {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.location = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Experiment_Location>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Location): Experiment_Location {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* discord_protos.discord_experimentation.v1.Experiment.ISORegion iso_region */ 1:
                    message.location = {
                        oneofKind: "isoRegion",
                        isoRegion: Experiment_ISORegion.internalBinaryRead(reader, reader.uint32(), options, (message.location as any).isoRegion)
                    };
                    break;
                case /* bool is_eu */ 2:
                    message.location = {
                        oneofKind: "isEu",
                        isEu: reader.bool()
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Place place */ 3:
                    message.location = {
                        oneofKind: "place",
                        place: Experiment_Place.internalBinaryRead(reader, reader.uint32(), options, (message.location as any).place)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Location, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* discord_protos.discord_experimentation.v1.Experiment.ISORegion iso_region = 1; */
        if (message.location.oneofKind === "isoRegion")
            Experiment_ISORegion.internalBinaryWrite(message.location.isoRegion, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool is_eu = 2; */
        if (message.location.oneofKind === "isEu")
            writer.tag(2, WireType.Varint).bool(message.location.isEu);
        /* discord_protos.discord_experimentation.v1.Experiment.Place place = 3; */
        if (message.location.oneofKind === "place")
            Experiment_Place.internalBinaryWrite(message.location.place, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Location
 */
export const Experiment_Location = new Experiment_Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientLocation$Type extends MessageType<Experiment_ClientLocation> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientLocation", [
            { no: 1, name: "locations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_Location }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientLocation>): Experiment_ClientLocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locations = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientLocation): Experiment_ClientLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.Location locations */ 1:
                    message.locations.push(Experiment_Location.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated discord_protos.discord_experimentation.v1.Experiment.Location locations = 1; */
        for (let i = 0; i < message.locations.length; i++)
            Experiment_Location.internalBinaryWrite(message.locations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientLocation
 */
export const Experiment_ClientLocation = new Experiment_ClientLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientIP$Type extends MessageType<Experiment_ClientIP> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientIP", [
            { no: 1, name: "blocks", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientIP>): Experiment_ClientIP {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.blocks = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientIP>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientIP): Experiment_ClientIP {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string blocks = 1 [packed = false] */ 1:
                    message.blocks.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientIP, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string blocks = 1 [packed = false]; */
        for (let i = 0; i < message.blocks.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.blocks[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientIP
 */
export const Experiment_ClientIP = new Experiment_ClientIP$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserLocale$Type extends MessageType<Experiment_UserLocale> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserLocale", [
            { no: 1, name: "locales", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserLocale>): Experiment_UserLocale {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locales = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserLocale>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserLocale): Experiment_UserLocale {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string locales = 1 [packed = false] */ 1:
                    message.locales.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserLocale, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string locales = 1 [packed = false]; */
        for (let i = 0; i < message.locales.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.locales[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserLocale
 */
export const Experiment_UserLocale = new Experiment_UserLocale$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserIsBot$Type extends MessageType<Experiment_UserIsBot> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserIsBot", [
            { no: 1, name: "is_bot", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserIsBot>): Experiment_UserIsBot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isBot = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserIsBot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserIsBot): Experiment_UserIsBot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_bot */ 1:
                    message.isBot = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserIsBot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_bot = 1; */
        if (message.isBot !== false)
            writer.tag(1, WireType.Varint).bool(message.isBot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIsBot
 */
export const Experiment_UserIsBot = new Experiment_UserIsBot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserAgeRange$Type extends MessageType<Experiment_UserAgeRange> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserAgeRange", [
            { no: 1, name: "min_age_years", kind: "message", T: () => UInt32Value },
            { no: 2, name: "max_age_years", kind: "message", T: () => UInt32Value }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserAgeRange>): Experiment_UserAgeRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserAgeRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserAgeRange): Experiment_UserAgeRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.UInt32Value min_age_years */ 1:
                    message.minAgeYears = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.minAgeYears);
                    break;
                case /* optional google.protobuf.UInt32Value max_age_years */ 2:
                    message.maxAgeYears = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxAgeYears);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserAgeRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.UInt32Value min_age_years = 1; */
        if (message.minAgeYears)
            UInt32Value.internalBinaryWrite(message.minAgeYears, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.UInt32Value max_age_years = 2; */
        if (message.maxAgeYears)
            UInt32Value.internalBinaryWrite(message.maxAgeYears, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserAgeRange
 */
export const Experiment_UserAgeRange = new Experiment_UserAgeRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Fixed64Value$Type extends MessageType<Experiment_Fixed64Value> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Fixed64Value", [
            { no: 1, name: "value", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_Fixed64Value>): Experiment_Fixed64Value {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0n;
        if (value !== undefined)
            reflectionMergePartial<Experiment_Fixed64Value>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Fixed64Value): Experiment_Fixed64Value {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed64 value */ 1:
                    message.value = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Fixed64Value, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed64 value = 1; */
        if (message.value !== 0n)
            writer.tag(1, WireType.Bit64).fixed64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Fixed64Value
 */
export const Experiment_Fixed64Value = new Experiment_Fixed64Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserIDRange$Type extends MessageType<Experiment_UserIDRange> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserIDRange", [
            { no: 1, name: "min_id", kind: "message", T: () => Experiment_Fixed64Value },
            { no: 2, name: "max_id", kind: "message", T: () => Experiment_Fixed64Value }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserIDRange>): Experiment_UserIDRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserIDRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserIDRange): Experiment_UserIDRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value min_id */ 1:
                    message.minId = Experiment_Fixed64Value.internalBinaryRead(reader, reader.uint32(), options, message.minId);
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value max_id */ 2:
                    message.maxId = Experiment_Fixed64Value.internalBinaryRead(reader, reader.uint32(), options, message.maxId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserIDRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value min_id = 1; */
        if (message.minId)
            Experiment_Fixed64Value.internalBinaryWrite(message.minId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.Fixed64Value max_id = 2; */
        if (message.maxId)
            Experiment_Fixed64Value.internalBinaryWrite(message.maxId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserIDRange
 */
export const Experiment_UserIDRange = new Experiment_UserIDRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserHasFlag$Type extends MessageType<Experiment_UserHasFlag> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserHasFlag", [
            { no: 1, name: "mask", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserHasFlag>): Experiment_UserHasFlag {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mask = 0n;
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserHasFlag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserHasFlag): Experiment_UserHasFlag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed64 mask */ 1:
                    message.mask = reader.fixed64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserHasFlag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed64 mask = 1; */
        if (message.mask !== 0n)
            writer.tag(1, WireType.Bit64).fixed64(message.mask);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserHasFlag
 */
export const Experiment_UserHasFlag = new Experiment_UserHasFlag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UnitIdInRangeByHash$Type extends MessageType<Experiment_UnitIdInRangeByHash> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash", [
            { no: 1, name: "hash_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "stop_ring_position", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "start_ring_position", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UnitIdInRangeByHash>): Experiment_UnitIdInRangeByHash {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hashKey = "";
        message.stopRingPosition = 0;
        message.startRingPosition = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_UnitIdInRangeByHash>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UnitIdInRangeByHash): Experiment_UnitIdInRangeByHash {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hash_key */ 1:
                    message.hashKey = reader.string();
                    break;
                case /* uint32 stop_ring_position */ 2:
                    message.stopRingPosition = reader.uint32();
                    break;
                case /* uint32 start_ring_position */ 3:
                    message.startRingPosition = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UnitIdInRangeByHash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hash_key = 1; */
        if (message.hashKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hashKey);
        /* uint32 stop_ring_position = 2; */
        if (message.stopRingPosition !== 0)
            writer.tag(2, WireType.Varint).uint32(message.stopRingPosition);
        /* uint32 start_ring_position = 3; */
        if (message.startRingPosition !== 0)
            writer.tag(3, WireType.Varint).uint32(message.startRingPosition);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash
 */
export const Experiment_UnitIdInRangeByHash = new Experiment_UnitIdInRangeByHash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientReleaseChannel$Type extends MessageType<Experiment_ClientReleaseChannel> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel", [
            { no: 1, name: "release_channels", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientReleaseChannel>): Experiment_ClientReleaseChannel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.releaseChannels = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientReleaseChannel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientReleaseChannel): Experiment_ClientReleaseChannel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string release_channels = 1 [packed = false] */ 1:
                    message.releaseChannels.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientReleaseChannel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string release_channels = 1 [packed = false]; */
        for (let i = 0; i < message.releaseChannels.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.releaseChannels[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel
 */
export const Experiment_ClientReleaseChannel = new Experiment_ClientReleaseChannel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Always$Type extends MessageType<Experiment_Always> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Always", [
            { no: 1, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_Always>): Experiment_Always {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = false;
        if (value !== undefined)
            reflectionMergePartial<Experiment_Always>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Always): Experiment_Always {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool value */ 1:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Always, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool value = 1; */
        if (message.value !== false)
            writer.tag(1, WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Always
 */
export const Experiment_Always = new Experiment_Always$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_ClientSystemLocale$Type extends MessageType<Experiment_ClientSystemLocale> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.ClientSystemLocale", [
            { no: 1, name: "locales", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_ClientSystemLocale>): Experiment_ClientSystemLocale {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locales = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_ClientSystemLocale>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_ClientSystemLocale): Experiment_ClientSystemLocale {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string locales = 1 [packed = false] */ 1:
                    message.locales.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_ClientSystemLocale, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string locales = 1 [packed = false]; */
        for (let i = 0; i < message.locales.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.locales[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.ClientSystemLocale
 */
export const Experiment_ClientSystemLocale = new Experiment_ClientSystemLocale$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UnitIdInExperiment$Type extends MessageType<Experiment_UnitIdInExperiment> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UnitIdInExperiment", [
            { no: 1, name: "experiment_id", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "variation_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UnitIdInExperiment>): Experiment_UnitIdInExperiment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.experimentId = 0n;
        message.variationIds = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_UnitIdInExperiment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UnitIdInExperiment): Experiment_UnitIdInExperiment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed64 experiment_id */ 1:
                    message.experimentId = reader.fixed64().toBigInt();
                    break;
                case /* repeated int32 variation_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.variationIds.push(reader.int32());
                    else
                        message.variationIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UnitIdInExperiment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed64 experiment_id = 1; */
        if (message.experimentId !== 0n)
            writer.tag(1, WireType.Bit64).fixed64(message.experimentId);
        /* repeated int32 variation_ids = 2; */
        if (message.variationIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.variationIds.length; i++)
                writer.int32(message.variationIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UnitIdInExperiment
 */
export const Experiment_UnitIdInExperiment = new Experiment_UnitIdInExperiment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UserPremiumType$Type extends MessageType<Experiment_UserPremiumType> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UserPremiumType", [
            { no: 1, name: "premium_types", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UserPremiumType>): Experiment_UserPremiumType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.premiumTypes = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_UserPremiumType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UserPremiumType): Experiment_UserPremiumType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 premium_types */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.premiumTypes.push(reader.int32());
                    else
                        message.premiumTypes.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UserPremiumType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 premium_types = 1; */
        if (message.premiumTypes.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.premiumTypes.length; i++)
                writer.int32(message.premiumTypes[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UserPremiumType
 */
export const Experiment_UserPremiumType = new Experiment_UserPremiumType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_UnitIdMatchesFilterSnapshot$Type extends MessageType<Experiment_UnitIdMatchesFilterSnapshot> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.UnitIdMatchesFilterSnapshot", [
            { no: 1, name: "filter_snapshot_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_filter_values", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_UnitIdMatchesFilterSnapshot>): Experiment_UnitIdMatchesFilterSnapshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filterSnapshotName = "";
        message.targetFilterValues = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_UnitIdMatchesFilterSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_UnitIdMatchesFilterSnapshot): Experiment_UnitIdMatchesFilterSnapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string filter_snapshot_name */ 1:
                    message.filterSnapshotName = reader.string();
                    break;
                case /* repeated fixed64 target_filter_values */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.targetFilterValues.push(reader.fixed64().toBigInt());
                    else
                        message.targetFilterValues.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_UnitIdMatchesFilterSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string filter_snapshot_name = 1; */
        if (message.filterSnapshotName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.filterSnapshotName);
        /* repeated fixed64 target_filter_values = 2; */
        if (message.targetFilterValues.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.targetFilterValues.length; i++)
                writer.fixed64(message.targetFilterValues[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.UnitIdMatchesFilterSnapshot
 */
export const Experiment_UnitIdMatchesFilterSnapshot = new Experiment_UnitIdMatchesFilterSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_GuildIds$Type extends MessageType<Experiment_GuildIds> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.GuildIds", [
            { no: 1, name: "guild_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_GuildIds>): Experiment_GuildIds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.guildIds = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_GuildIds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_GuildIds): Experiment_GuildIds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 guild_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.guildIds.push(reader.fixed64().toBigInt());
                    else
                        message.guildIds.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_GuildIds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 guild_ids = 1; */
        if (message.guildIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.guildIds.length; i++)
                writer.fixed64(message.guildIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.GuildIds
 */
export const Experiment_GuildIds = new Experiment_GuildIds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_GuildMemberCountRange$Type extends MessageType<Experiment_GuildMemberCountRange> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.GuildMemberCountRange", [
            { no: 1, name: "min_count", kind: "message", T: () => UInt32Value },
            { no: 2, name: "max_count", kind: "message", T: () => UInt32Value }
        ]);
    }
    create(value?: PartialMessage<Experiment_GuildMemberCountRange>): Experiment_GuildMemberCountRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Experiment_GuildMemberCountRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_GuildMemberCountRange): Experiment_GuildMemberCountRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.UInt32Value min_count */ 1:
                    message.minCount = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.minCount);
                    break;
                case /* optional google.protobuf.UInt32Value max_count */ 2:
                    message.maxCount = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxCount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_GuildMemberCountRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.UInt32Value min_count = 1; */
        if (message.minCount)
            UInt32Value.internalBinaryWrite(message.minCount, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional google.protobuf.UInt32Value max_count = 2; */
        if (message.maxCount)
            UInt32Value.internalBinaryWrite(message.maxCount, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.GuildMemberCountRange
 */
export const Experiment_GuildMemberCountRange = new Experiment_GuildMemberCountRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_GuildHasFeature$Type extends MessageType<Experiment_GuildHasFeature> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.GuildHasFeature", [
            { no: 1, name: "features", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_GuildHasFeature>): Experiment_GuildHasFeature {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.features = [];
        if (value !== undefined)
            reflectionMergePartial<Experiment_GuildHasFeature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_GuildHasFeature): Experiment_GuildHasFeature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string features = 1 [packed = false] */ 1:
                    message.features.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_GuildHasFeature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string features = 1 [packed = false]; */
        for (let i = 0; i < message.features.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.features[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.GuildHasFeature
 */
export const Experiment_GuildHasFeature = new Experiment_GuildHasFeature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Filter$Type extends MessageType<Experiment_Filter> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Filter", [
            { no: 2, name: "client_version", kind: "message", oneof: "filter", T: () => Experiment_ClientPlatform },
            { no: 3, name: "client_os", kind: "message", oneof: "filter", T: () => Experiment_ClientOperatingSystem },
            { no: 4, name: "staff", kind: "message", oneof: "filter", T: () => Experiment_StaffUsers },
            { no: 5, name: "user_in_guild", kind: "message", oneof: "filter", T: () => Experiment_UserInGuild },
            { no: 6, name: "user_ids", kind: "message", oneof: "filter", T: () => Experiment_UserIds },
            { no: 7, name: "client_locale", kind: "message", oneof: "filter", T: () => Experiment_ClientLocale },
            { no: 8, name: "client_location", kind: "message", oneof: "filter", T: () => Experiment_ClientLocation },
            { no: 9, name: "client_ip", kind: "message", oneof: "filter", T: () => Experiment_ClientIP },
            { no: 10, name: "user_locale", kind: "message", oneof: "filter", T: () => Experiment_UserLocale },
            { no: 11, name: "bot", kind: "message", oneof: "filter", T: () => Experiment_UserIsBot },
            { no: 12, name: "user_age_range", kind: "message", oneof: "filter", T: () => Experiment_UserAgeRange },
            { no: 13, name: "user_id_range", kind: "message", oneof: "filter", T: () => Experiment_UserIDRange },
            { no: 14, name: "user_has_flag", kind: "message", oneof: "filter", T: () => Experiment_UserHasFlag },
            { no: 15, name: "unit_id_in_range_by_hash", kind: "message", oneof: "filter", T: () => Experiment_UnitIdInRangeByHash },
            { no: 16, name: "client_release_channel", kind: "message", oneof: "filter", T: () => Experiment_ClientReleaseChannel },
            { no: 17, name: "always", kind: "message", oneof: "filter", T: () => Experiment_Always },
            { no: 18, name: "client_system_locale", kind: "message", oneof: "filter", T: () => Experiment_ClientSystemLocale },
            { no: 19, name: "unit_id_in_experiment", kind: "message", oneof: "filter", T: () => Experiment_UnitIdInExperiment },
            { no: 20, name: "user_premium_type", kind: "message", oneof: "filter", T: () => Experiment_UserPremiumType },
            { no: 21, name: "unit_id_matches_filter_snapshot", kind: "message", oneof: "filter", T: () => Experiment_UnitIdMatchesFilterSnapshot },
            { no: 22, name: "guild_ids", kind: "message", oneof: "filter", T: () => Experiment_GuildIds },
            { no: 25, name: "guild_member_count_range", kind: "message", oneof: "filter", T: () => Experiment_GuildMemberCountRange },
            { no: 26, name: "guild_has_feature", kind: "message", oneof: "filter", T: () => Experiment_GuildHasFeature }
        ]);
    }
    create(value?: PartialMessage<Experiment_Filter>): Experiment_Filter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filter = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Experiment_Filter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Filter): Experiment_Filter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientPlatform client_version */ 2:
                    message.filter = {
                        oneofKind: "clientVersion",
                        clientVersion: Experiment_ClientPlatform.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientVersion)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem client_os */ 3:
                    message.filter = {
                        oneofKind: "clientOs",
                        clientOs: Experiment_ClientOperatingSystem.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientOs)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.StaffUsers staff */ 4:
                    message.filter = {
                        oneofKind: "staff",
                        staff: Experiment_StaffUsers.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).staff)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserInGuild user_in_guild */ 5:
                    message.filter = {
                        oneofKind: "userInGuild",
                        userInGuild: Experiment_UserInGuild.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userInGuild)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserIds user_ids */ 6:
                    message.filter = {
                        oneofKind: "userIds",
                        userIds: Experiment_UserIds.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userIds)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientLocale client_locale */ 7:
                    message.filter = {
                        oneofKind: "clientLocale",
                        clientLocale: Experiment_ClientLocale.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientLocale)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientLocation client_location */ 8:
                    message.filter = {
                        oneofKind: "clientLocation",
                        clientLocation: Experiment_ClientLocation.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientLocation)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientIP client_ip */ 9:
                    message.filter = {
                        oneofKind: "clientIp",
                        clientIp: Experiment_ClientIP.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientIp)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserLocale user_locale */ 10:
                    message.filter = {
                        oneofKind: "userLocale",
                        userLocale: Experiment_UserLocale.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userLocale)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserIsBot bot */ 11:
                    message.filter = {
                        oneofKind: "bot",
                        bot: Experiment_UserIsBot.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).bot)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserAgeRange user_age_range */ 12:
                    message.filter = {
                        oneofKind: "userAgeRange",
                        userAgeRange: Experiment_UserAgeRange.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userAgeRange)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserIDRange user_id_range */ 13:
                    message.filter = {
                        oneofKind: "userIdRange",
                        userIdRange: Experiment_UserIDRange.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userIdRange)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserHasFlag user_has_flag */ 14:
                    message.filter = {
                        oneofKind: "userHasFlag",
                        userHasFlag: Experiment_UserHasFlag.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userHasFlag)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash unit_id_in_range_by_hash */ 15:
                    message.filter = {
                        oneofKind: "unitIdInRangeByHash",
                        unitIdInRangeByHash: Experiment_UnitIdInRangeByHash.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).unitIdInRangeByHash)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel client_release_channel */ 16:
                    message.filter = {
                        oneofKind: "clientReleaseChannel",
                        clientReleaseChannel: Experiment_ClientReleaseChannel.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientReleaseChannel)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Always always */ 17:
                    message.filter = {
                        oneofKind: "always",
                        always: Experiment_Always.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).always)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.ClientSystemLocale client_system_locale */ 18:
                    message.filter = {
                        oneofKind: "clientSystemLocale",
                        clientSystemLocale: Experiment_ClientSystemLocale.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).clientSystemLocale)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UnitIdInExperiment unit_id_in_experiment */ 19:
                    message.filter = {
                        oneofKind: "unitIdInExperiment",
                        unitIdInExperiment: Experiment_UnitIdInExperiment.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).unitIdInExperiment)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UserPremiumType user_premium_type */ 20:
                    message.filter = {
                        oneofKind: "userPremiumType",
                        userPremiumType: Experiment_UserPremiumType.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).userPremiumType)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.UnitIdMatchesFilterSnapshot unit_id_matches_filter_snapshot */ 21:
                    message.filter = {
                        oneofKind: "unitIdMatchesFilterSnapshot",
                        unitIdMatchesFilterSnapshot: Experiment_UnitIdMatchesFilterSnapshot.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).unitIdMatchesFilterSnapshot)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.GuildIds guild_ids */ 22:
                    message.filter = {
                        oneofKind: "guildIds",
                        guildIds: Experiment_GuildIds.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).guildIds)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.GuildMemberCountRange guild_member_count_range */ 25:
                    message.filter = {
                        oneofKind: "guildMemberCountRange",
                        guildMemberCountRange: Experiment_GuildMemberCountRange.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).guildMemberCountRange)
                    };
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.GuildHasFeature guild_has_feature */ 26:
                    message.filter = {
                        oneofKind: "guildHasFeature",
                        guildHasFeature: Experiment_GuildHasFeature.internalBinaryRead(reader, reader.uint32(), options, (message.filter as any).guildHasFeature)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Filter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* discord_protos.discord_experimentation.v1.Experiment.ClientPlatform client_version = 2; */
        if (message.filter.oneofKind === "clientVersion")
            Experiment_ClientPlatform.internalBinaryWrite(message.filter.clientVersion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.ClientOperatingSystem client_os = 3; */
        if (message.filter.oneofKind === "clientOs")
            Experiment_ClientOperatingSystem.internalBinaryWrite(message.filter.clientOs, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.StaffUsers staff = 4; */
        if (message.filter.oneofKind === "staff")
            Experiment_StaffUsers.internalBinaryWrite(message.filter.staff, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserInGuild user_in_guild = 5; */
        if (message.filter.oneofKind === "userInGuild")
            Experiment_UserInGuild.internalBinaryWrite(message.filter.userInGuild, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserIds user_ids = 6; */
        if (message.filter.oneofKind === "userIds")
            Experiment_UserIds.internalBinaryWrite(message.filter.userIds, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.ClientLocale client_locale = 7; */
        if (message.filter.oneofKind === "clientLocale")
            Experiment_ClientLocale.internalBinaryWrite(message.filter.clientLocale, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.ClientLocation client_location = 8; */
        if (message.filter.oneofKind === "clientLocation")
            Experiment_ClientLocation.internalBinaryWrite(message.filter.clientLocation, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.ClientIP client_ip = 9; */
        if (message.filter.oneofKind === "clientIp")
            Experiment_ClientIP.internalBinaryWrite(message.filter.clientIp, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserLocale user_locale = 10; */
        if (message.filter.oneofKind === "userLocale")
            Experiment_UserLocale.internalBinaryWrite(message.filter.userLocale, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserIsBot bot = 11; */
        if (message.filter.oneofKind === "bot")
            Experiment_UserIsBot.internalBinaryWrite(message.filter.bot, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserAgeRange user_age_range = 12; */
        if (message.filter.oneofKind === "userAgeRange")
            Experiment_UserAgeRange.internalBinaryWrite(message.filter.userAgeRange, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserIDRange user_id_range = 13; */
        if (message.filter.oneofKind === "userIdRange")
            Experiment_UserIDRange.internalBinaryWrite(message.filter.userIdRange, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserHasFlag user_has_flag = 14; */
        if (message.filter.oneofKind === "userHasFlag")
            Experiment_UserHasFlag.internalBinaryWrite(message.filter.userHasFlag, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UnitIdInRangeByHash unit_id_in_range_by_hash = 15; */
        if (message.filter.oneofKind === "unitIdInRangeByHash")
            Experiment_UnitIdInRangeByHash.internalBinaryWrite(message.filter.unitIdInRangeByHash, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.ClientReleaseChannel client_release_channel = 16; */
        if (message.filter.oneofKind === "clientReleaseChannel")
            Experiment_ClientReleaseChannel.internalBinaryWrite(message.filter.clientReleaseChannel, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.Always always = 17; */
        if (message.filter.oneofKind === "always")
            Experiment_Always.internalBinaryWrite(message.filter.always, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.ClientSystemLocale client_system_locale = 18; */
        if (message.filter.oneofKind === "clientSystemLocale")
            Experiment_ClientSystemLocale.internalBinaryWrite(message.filter.clientSystemLocale, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UnitIdInExperiment unit_id_in_experiment = 19; */
        if (message.filter.oneofKind === "unitIdInExperiment")
            Experiment_UnitIdInExperiment.internalBinaryWrite(message.filter.unitIdInExperiment, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UserPremiumType user_premium_type = 20; */
        if (message.filter.oneofKind === "userPremiumType")
            Experiment_UserPremiumType.internalBinaryWrite(message.filter.userPremiumType, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.UnitIdMatchesFilterSnapshot unit_id_matches_filter_snapshot = 21; */
        if (message.filter.oneofKind === "unitIdMatchesFilterSnapshot")
            Experiment_UnitIdMatchesFilterSnapshot.internalBinaryWrite(message.filter.unitIdMatchesFilterSnapshot, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.GuildIds guild_ids = 22; */
        if (message.filter.oneofKind === "guildIds")
            Experiment_GuildIds.internalBinaryWrite(message.filter.guildIds, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.GuildMemberCountRange guild_member_count_range = 25; */
        if (message.filter.oneofKind === "guildMemberCountRange")
            Experiment_GuildMemberCountRange.internalBinaryWrite(message.filter.guildMemberCountRange, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* discord_protos.discord_experimentation.v1.Experiment.GuildHasFeature guild_has_feature = 26; */
        if (message.filter.oneofKind === "guildHasFeature")
            Experiment_GuildHasFeature.internalBinaryWrite(message.filter.guildHasFeature, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Filter
 */
export const Experiment_Filter = new Experiment_Filter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Override$Type extends MessageType<Experiment_Override> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Override", [
            { no: 1, name: "variation_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_Override>): Experiment_Override {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.variationId = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_Override>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Override): Experiment_Override {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 variation_id */ 1:
                    message.variationId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Override, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 variation_id = 1; */
        if (message.variationId !== 0)
            writer.tag(1, WireType.Varint).int32(message.variationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Override
 */
export const Experiment_Override = new Experiment_Override$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_Rule$Type extends MessageType<Experiment_Rule> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.Rule", [
            { no: 1, name: "type", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.Type", Experiment_Type, "TYPE_"] },
            { no: 2, name: "filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Experiment_Filter },
            { no: 3, name: "override", kind: "message", T: () => Experiment_Override },
            { no: 4, name: "is_sunset_rule", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "subtype", kind: "enum", T: () => ["discord_protos.discord_experimentation.v1.Experiment.Subtype", Experiment_Subtype, "SUBTYPE_"] }
        ]);
    }
    create(value?: PartialMessage<Experiment_Rule>): Experiment_Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.filters = [];
        message.isSunsetRule = false;
        message.subtype = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_Rule): Experiment_Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* discord_protos.discord_experimentation.v1.Experiment.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* repeated discord_protos.discord_experimentation.v1.Experiment.Filter filters */ 2:
                    message.filters.push(Experiment_Filter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional discord_protos.discord_experimentation.v1.Experiment.Override override */ 3:
                    message.override = Experiment_Override.internalBinaryRead(reader, reader.uint32(), options, message.override);
                    break;
                case /* bool is_sunset_rule */ 4:
                    message.isSunsetRule = reader.bool();
                    break;
                case /* discord_protos.discord_experimentation.v1.Experiment.Subtype subtype */ 5:
                    message.subtype = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* discord_protos.discord_experimentation.v1.Experiment.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* repeated discord_protos.discord_experimentation.v1.Experiment.Filter filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            Experiment_Filter.internalBinaryWrite(message.filters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_experimentation.v1.Experiment.Override override = 3; */
        if (message.override)
            Experiment_Override.internalBinaryWrite(message.override, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool is_sunset_rule = 4; */
        if (message.isSunsetRule !== false)
            writer.tag(4, WireType.Varint).bool(message.isSunsetRule);
        /* discord_protos.discord_experimentation.v1.Experiment.Subtype subtype = 5; */
        if (message.subtype !== 0)
            writer.tag(5, WireType.Varint).int32(message.subtype);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.Rule
 */
export const Experiment_Rule = new Experiment_Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Experiment_DebugConfig$Type extends MessageType<Experiment_DebugConfig> {
    constructor() {
        super("discord_protos.discord_experimentation.v1.Experiment.DebugConfig", [
            { no: 1, name: "enable_decision_logging", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "metrics_sample_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "log_context_on_failure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "log_raw_headers", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "tag_filter_metrics", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "decision_log_sample_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Experiment_DebugConfig>): Experiment_DebugConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enableDecisionLogging = false;
        message.metricsSampleRate = 0;
        message.logContextOnFailure = false;
        message.logRawHeaders = false;
        message.tagFilterMetrics = false;
        message.decisionLogSampleRate = 0;
        if (value !== undefined)
            reflectionMergePartial<Experiment_DebugConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Experiment_DebugConfig): Experiment_DebugConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enable_decision_logging */ 1:
                    message.enableDecisionLogging = reader.bool();
                    break;
                case /* double metrics_sample_rate */ 2:
                    message.metricsSampleRate = reader.double();
                    break;
                case /* bool log_context_on_failure */ 3:
                    message.logContextOnFailure = reader.bool();
                    break;
                case /* bool log_raw_headers */ 4:
                    message.logRawHeaders = reader.bool();
                    break;
                case /* bool tag_filter_metrics */ 5:
                    message.tagFilterMetrics = reader.bool();
                    break;
                case /* double decision_log_sample_rate */ 6:
                    message.decisionLogSampleRate = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Experiment_DebugConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enable_decision_logging = 1; */
        if (message.enableDecisionLogging !== false)
            writer.tag(1, WireType.Varint).bool(message.enableDecisionLogging);
        /* double metrics_sample_rate = 2; */
        if (message.metricsSampleRate !== 0)
            writer.tag(2, WireType.Bit64).double(message.metricsSampleRate);
        /* bool log_context_on_failure = 3; */
        if (message.logContextOnFailure !== false)
            writer.tag(3, WireType.Varint).bool(message.logContextOnFailure);
        /* bool log_raw_headers = 4; */
        if (message.logRawHeaders !== false)
            writer.tag(4, WireType.Varint).bool(message.logRawHeaders);
        /* bool tag_filter_metrics = 5; */
        if (message.tagFilterMetrics !== false)
            writer.tag(5, WireType.Varint).bool(message.tagFilterMetrics);
        /* double decision_log_sample_rate = 6; */
        if (message.decisionLogSampleRate !== 0)
            writer.tag(6, WireType.Bit64).double(message.decisionLogSampleRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_experimentation.v1.Experiment.DebugConfig
 */
export const Experiment_DebugConfig = new Experiment_DebugConfig$Type();
