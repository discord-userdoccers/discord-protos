// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "FrecencyUserSettings.proto" (package "discord_protos.discord_users.v1.FrecencyUserSettings", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings
 */
export interface FrecencyUserSettings {
    /**
     * @generated from protobuf field: optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.Versions versions = 1;
     */
    versions?: FrecencyUserSettings_Versions;
    /**
     * @generated from protobuf field: optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIFs favorite_gifs = 2;
     */
    favoriteGifs?: FrecencyUserSettings_FavoriteGIFs;
    /**
     * @generated from protobuf field: optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteStickers favorite_stickers = 3;
     */
    favoriteStickers?: FrecencyUserSettings_FavoriteStickers;
    /**
     * @generated from protobuf field: optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.StickerFrecency sticker_frecency = 4;
     */
    stickerFrecency?: FrecencyUserSettings_StickerFrecency;
    /**
     * @generated from protobuf field: optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteEmojis favorite_emojis = 5;
     */
    favoriteEmojis?: FrecencyUserSettings_FavoriteEmojis;
    /**
     * @generated from protobuf field: optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.EmojiFrecency emoji_frecency = 6;
     */
    emojiFrecency?: FrecencyUserSettings_EmojiFrecency;
    /**
     * @generated from protobuf field: optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.ApplicationCommandFrecency application_command_frecency = 7;
     */
    applicationCommandFrecency?: FrecencyUserSettings_ApplicationCommandFrecency;
}
/**
 * @generated from protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.Versions
 */
export interface FrecencyUserSettings_Versions {
    /**
     * @generated from protobuf field: uint32 client_version = 1;
     */
    clientVersion: number;
    /**
     * @generated from protobuf field: uint32 server_version = 2;
     */
    serverVersion: number;
    /**
     * @generated from protobuf field: uint32 data_version = 3;
     */
    dataVersion: number;
}
/**
 * @generated from protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIF
 */
export interface FrecencyUserSettings_FavoriteGIF {
    /**
     * @generated from protobuf field: discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.GIFType format = 1;
     */
    format: FrecencyUserSettings_GIFType;
    /**
     * @generated from protobuf field: string src = 2;
     */
    src: string;
    /**
     * @generated from protobuf field: uint32 width = 3;
     */
    width: number;
    /**
     * @generated from protobuf field: uint32 height = 4;
     */
    height: number;
    /**
     * @generated from protobuf field: uint32 order = 5;
     */
    order: number;
}
/**
 * @generated from protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIFs
 */
export interface FrecencyUserSettings_FavoriteGIFs {
    /**
     * @generated from protobuf field: map<string, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIF> gifs = 1;
     */
    gifs: {
        [key: string]: FrecencyUserSettings_FavoriteGIF;
    };
    /**
     * @generated from protobuf field: bool hide_tooltip = 2;
     */
    hideTooltip: boolean;
}
/**
 * @generated from protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteStickers
 */
export interface FrecencyUserSettings_FavoriteStickers {
    /**
     * @generated from protobuf field: repeated fixed64 sticker_ids = 1;
     */
    stickerIds: bigint[];
}
/**
 * @generated from protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem
 */
export interface FrecencyUserSettings_FrecencyItem {
    /**
     * @generated from protobuf field: uint32 total_uses = 1;
     */
    totalUses: number;
    /**
     * @generated from protobuf field: repeated uint64 recent_uses = 2;
     */
    recentUses: bigint[];
    /**
     * @generated from protobuf field: int32 frecency = 3;
     */
    frecency: number;
    /**
     * @generated from protobuf field: int32 score = 4;
     */
    score: number;
}
/**
 * @generated from protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.StickerFrecency
 */
export interface FrecencyUserSettings_StickerFrecency {
    /**
     * @generated from protobuf field: map<fixed64, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem> stickers = 1;
     */
    stickers: {
        [key: string]: FrecencyUserSettings_FrecencyItem;
    };
}
/**
 * @generated from protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteEmojis
 */
export interface FrecencyUserSettings_FavoriteEmojis {
    /**
     * @generated from protobuf field: repeated string emojis = 1;
     */
    emojis: string[];
}
/**
 * @generated from protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.EmojiFrecency
 */
export interface FrecencyUserSettings_EmojiFrecency {
    /**
     * @generated from protobuf field: map<string, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem> emojis = 1;
     */
    emojis: {
        [key: string]: FrecencyUserSettings_FrecencyItem;
    };
}
/**
 * @generated from protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.ApplicationCommandFrecency
 */
export interface FrecencyUserSettings_ApplicationCommandFrecency {
    /**
     * @generated from protobuf field: map<string, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem> application_commands = 1;
     */
    applicationCommands: {
        [key: string]: FrecencyUserSettings_FrecencyItem;
    };
}
/**
 * @generated from protobuf enum discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.GIFType
 */
export enum FrecencyUserSettings_GIFType {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: IMAGE = 1;
     */
    IMAGE = 1,
    /**
     * @generated from protobuf enum value: VIDEO = 2;
     */
    VIDEO = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class FrecencyUserSettings$Type extends MessageType<FrecencyUserSettings> {
    constructor() {
        super("discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings", [
            { no: 1, name: "versions", kind: "message", T: () => FrecencyUserSettings_Versions },
            { no: 2, name: "favorite_gifs", kind: "message", T: () => FrecencyUserSettings_FavoriteGIFs },
            { no: 3, name: "favorite_stickers", kind: "message", T: () => FrecencyUserSettings_FavoriteStickers },
            { no: 4, name: "sticker_frecency", kind: "message", T: () => FrecencyUserSettings_StickerFrecency },
            { no: 5, name: "favorite_emojis", kind: "message", T: () => FrecencyUserSettings_FavoriteEmojis },
            { no: 6, name: "emoji_frecency", kind: "message", T: () => FrecencyUserSettings_EmojiFrecency },
            { no: 7, name: "application_command_frecency", kind: "message", T: () => FrecencyUserSettings_ApplicationCommandFrecency }
        ]);
    }
    create(value?: PartialMessage<FrecencyUserSettings>): FrecencyUserSettings {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FrecencyUserSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrecencyUserSettings): FrecencyUserSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.Versions versions */ 1:
                    message.versions = FrecencyUserSettings_Versions.internalBinaryRead(reader, reader.uint32(), options, message.versions);
                    break;
                case /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIFs favorite_gifs */ 2:
                    message.favoriteGifs = FrecencyUserSettings_FavoriteGIFs.internalBinaryRead(reader, reader.uint32(), options, message.favoriteGifs);
                    break;
                case /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteStickers favorite_stickers */ 3:
                    message.favoriteStickers = FrecencyUserSettings_FavoriteStickers.internalBinaryRead(reader, reader.uint32(), options, message.favoriteStickers);
                    break;
                case /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.StickerFrecency sticker_frecency */ 4:
                    message.stickerFrecency = FrecencyUserSettings_StickerFrecency.internalBinaryRead(reader, reader.uint32(), options, message.stickerFrecency);
                    break;
                case /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteEmojis favorite_emojis */ 5:
                    message.favoriteEmojis = FrecencyUserSettings_FavoriteEmojis.internalBinaryRead(reader, reader.uint32(), options, message.favoriteEmojis);
                    break;
                case /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.EmojiFrecency emoji_frecency */ 6:
                    message.emojiFrecency = FrecencyUserSettings_EmojiFrecency.internalBinaryRead(reader, reader.uint32(), options, message.emojiFrecency);
                    break;
                case /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.ApplicationCommandFrecency application_command_frecency */ 7:
                    message.applicationCommandFrecency = FrecencyUserSettings_ApplicationCommandFrecency.internalBinaryRead(reader, reader.uint32(), options, message.applicationCommandFrecency);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FrecencyUserSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.Versions versions = 1; */
        if (message.versions)
            FrecencyUserSettings_Versions.internalBinaryWrite(message.versions, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIFs favorite_gifs = 2; */
        if (message.favoriteGifs)
            FrecencyUserSettings_FavoriteGIFs.internalBinaryWrite(message.favoriteGifs, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteStickers favorite_stickers = 3; */
        if (message.favoriteStickers)
            FrecencyUserSettings_FavoriteStickers.internalBinaryWrite(message.favoriteStickers, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.StickerFrecency sticker_frecency = 4; */
        if (message.stickerFrecency)
            FrecencyUserSettings_StickerFrecency.internalBinaryWrite(message.stickerFrecency, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteEmojis favorite_emojis = 5; */
        if (message.favoriteEmojis)
            FrecencyUserSettings_FavoriteEmojis.internalBinaryWrite(message.favoriteEmojis, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.EmojiFrecency emoji_frecency = 6; */
        if (message.emojiFrecency)
            FrecencyUserSettings_EmojiFrecency.internalBinaryWrite(message.emojiFrecency, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.ApplicationCommandFrecency application_command_frecency = 7; */
        if (message.applicationCommandFrecency)
            FrecencyUserSettings_ApplicationCommandFrecency.internalBinaryWrite(message.applicationCommandFrecency, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings
 */
export const FrecencyUserSettings = new FrecencyUserSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrecencyUserSettings_Versions$Type extends MessageType<FrecencyUserSettings_Versions> {
    constructor() {
        super("discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.Versions", [
            { no: 1, name: "client_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "server_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FrecencyUserSettings_Versions>): FrecencyUserSettings_Versions {
        const message = { clientVersion: 0, serverVersion: 0, dataVersion: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FrecencyUserSettings_Versions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrecencyUserSettings_Versions): FrecencyUserSettings_Versions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 client_version */ 1:
                    message.clientVersion = reader.uint32();
                    break;
                case /* uint32 server_version */ 2:
                    message.serverVersion = reader.uint32();
                    break;
                case /* uint32 data_version */ 3:
                    message.dataVersion = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FrecencyUserSettings_Versions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 client_version = 1; */
        if (message.clientVersion !== 0)
            writer.tag(1, WireType.Varint).uint32(message.clientVersion);
        /* uint32 server_version = 2; */
        if (message.serverVersion !== 0)
            writer.tag(2, WireType.Varint).uint32(message.serverVersion);
        /* uint32 data_version = 3; */
        if (message.dataVersion !== 0)
            writer.tag(3, WireType.Varint).uint32(message.dataVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.Versions
 */
export const FrecencyUserSettings_Versions = new FrecencyUserSettings_Versions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrecencyUserSettings_FavoriteGIF$Type extends MessageType<FrecencyUserSettings_FavoriteGIF> {
    constructor() {
        super("discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIF", [
            { no: 1, name: "format", kind: "enum", T: () => ["discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.GIFType", FrecencyUserSettings_GIFType] },
            { no: 2, name: "src", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "width", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "height", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "order", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FrecencyUserSettings_FavoriteGIF>): FrecencyUserSettings_FavoriteGIF {
        const message = { format: 0, src: "", width: 0, height: 0, order: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FrecencyUserSettings_FavoriteGIF>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrecencyUserSettings_FavoriteGIF): FrecencyUserSettings_FavoriteGIF {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.GIFType format */ 1:
                    message.format = reader.int32();
                    break;
                case /* string src */ 2:
                    message.src = reader.string();
                    break;
                case /* uint32 width */ 3:
                    message.width = reader.uint32();
                    break;
                case /* uint32 height */ 4:
                    message.height = reader.uint32();
                    break;
                case /* uint32 order */ 5:
                    message.order = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FrecencyUserSettings_FavoriteGIF, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.GIFType format = 1; */
        if (message.format !== 0)
            writer.tag(1, WireType.Varint).int32(message.format);
        /* string src = 2; */
        if (message.src !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.src);
        /* uint32 width = 3; */
        if (message.width !== 0)
            writer.tag(3, WireType.Varint).uint32(message.width);
        /* uint32 height = 4; */
        if (message.height !== 0)
            writer.tag(4, WireType.Varint).uint32(message.height);
        /* uint32 order = 5; */
        if (message.order !== 0)
            writer.tag(5, WireType.Varint).uint32(message.order);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIF
 */
export const FrecencyUserSettings_FavoriteGIF = new FrecencyUserSettings_FavoriteGIF$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrecencyUserSettings_FavoriteGIFs$Type extends MessageType<FrecencyUserSettings_FavoriteGIFs> {
    constructor() {
        super("discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIFs", [
            { no: 1, name: "gifs", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => FrecencyUserSettings_FavoriteGIF } },
            { no: 2, name: "hide_tooltip", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FrecencyUserSettings_FavoriteGIFs>): FrecencyUserSettings_FavoriteGIFs {
        const message = { gifs: {}, hideTooltip: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FrecencyUserSettings_FavoriteGIFs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrecencyUserSettings_FavoriteGIFs): FrecencyUserSettings_FavoriteGIFs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIF> gifs */ 1:
                    this.binaryReadMap1(message.gifs, reader, options);
                    break;
                case /* bool hide_tooltip */ 2:
                    message.hideTooltip = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: FrecencyUserSettings_FavoriteGIFs["gifs"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FrecencyUserSettings_FavoriteGIFs["gifs"] | undefined, val: FrecencyUserSettings_FavoriteGIFs["gifs"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = FrecencyUserSettings_FavoriteGIF.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIFs.gifs");
            }
        }
        map[key ?? ""] = val ?? FrecencyUserSettings_FavoriteGIF.create();
    }
    internalBinaryWrite(message: FrecencyUserSettings_FavoriteGIFs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIF> gifs = 1; */
        for (let k of Object.keys(message.gifs)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            FrecencyUserSettings_FavoriteGIF.internalBinaryWrite(message.gifs[k], writer, options);
            writer.join().join();
        }
        /* bool hide_tooltip = 2; */
        if (message.hideTooltip !== false)
            writer.tag(2, WireType.Varint).bool(message.hideTooltip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteGIFs
 */
export const FrecencyUserSettings_FavoriteGIFs = new FrecencyUserSettings_FavoriteGIFs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrecencyUserSettings_FavoriteStickers$Type extends MessageType<FrecencyUserSettings_FavoriteStickers> {
    constructor() {
        super("discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteStickers", [
            { no: 1, name: "sticker_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FrecencyUserSettings_FavoriteStickers>): FrecencyUserSettings_FavoriteStickers {
        const message = { stickerIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FrecencyUserSettings_FavoriteStickers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrecencyUserSettings_FavoriteStickers): FrecencyUserSettings_FavoriteStickers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 sticker_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.stickerIds.push(reader.fixed64().toBigInt());
                    else
                        message.stickerIds.push(reader.fixed64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FrecencyUserSettings_FavoriteStickers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated fixed64 sticker_ids = 1; */
        if (message.stickerIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.stickerIds.length; i++)
                writer.fixed64(message.stickerIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteStickers
 */
export const FrecencyUserSettings_FavoriteStickers = new FrecencyUserSettings_FavoriteStickers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrecencyUserSettings_FrecencyItem$Type extends MessageType<FrecencyUserSettings_FrecencyItem> {
    constructor() {
        super("discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem", [
            { no: 1, name: "total_uses", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "recent_uses", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "frecency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FrecencyUserSettings_FrecencyItem>): FrecencyUserSettings_FrecencyItem {
        const message = { totalUses: 0, recentUses: [], frecency: 0, score: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FrecencyUserSettings_FrecencyItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrecencyUserSettings_FrecencyItem): FrecencyUserSettings_FrecencyItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total_uses */ 1:
                    message.totalUses = reader.uint32();
                    break;
                case /* repeated uint64 recent_uses */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.recentUses.push(reader.uint64().toBigInt());
                    else
                        message.recentUses.push(reader.uint64().toBigInt());
                    break;
                case /* int32 frecency */ 3:
                    message.frecency = reader.int32();
                    break;
                case /* int32 score */ 4:
                    message.score = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FrecencyUserSettings_FrecencyItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total_uses = 1; */
        if (message.totalUses !== 0)
            writer.tag(1, WireType.Varint).uint32(message.totalUses);
        /* repeated uint64 recent_uses = 2; */
        if (message.recentUses.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.recentUses.length; i++)
                writer.uint64(message.recentUses[i]);
            writer.join();
        }
        /* int32 frecency = 3; */
        if (message.frecency !== 0)
            writer.tag(3, WireType.Varint).int32(message.frecency);
        /* int32 score = 4; */
        if (message.score !== 0)
            writer.tag(4, WireType.Varint).int32(message.score);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem
 */
export const FrecencyUserSettings_FrecencyItem = new FrecencyUserSettings_FrecencyItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrecencyUserSettings_StickerFrecency$Type extends MessageType<FrecencyUserSettings_StickerFrecency> {
    constructor() {
        super("discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.StickerFrecency", [
            { no: 1, name: "stickers", kind: "map", K: 6 /*ScalarType.FIXED64*/, V: { kind: "message", T: () => FrecencyUserSettings_FrecencyItem } }
        ]);
    }
    create(value?: PartialMessage<FrecencyUserSettings_StickerFrecency>): FrecencyUserSettings_StickerFrecency {
        const message = { stickers: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FrecencyUserSettings_StickerFrecency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrecencyUserSettings_StickerFrecency): FrecencyUserSettings_StickerFrecency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<fixed64, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem> stickers */ 1:
                    this.binaryReadMap1(message.stickers, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: FrecencyUserSettings_StickerFrecency["stickers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FrecencyUserSettings_StickerFrecency["stickers"] | undefined, val: FrecencyUserSettings_StickerFrecency["stickers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.fixed64().toString();
                    break;
                case 2:
                    val = FrecencyUserSettings_FrecencyItem.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.StickerFrecency.stickers");
            }
        }
        map[key ?? "0"] = val ?? FrecencyUserSettings_FrecencyItem.create();
    }
    internalBinaryWrite(message: FrecencyUserSettings_StickerFrecency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<fixed64, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem> stickers = 1; */
        for (let k of Object.keys(message.stickers)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Bit64).fixed64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            FrecencyUserSettings_FrecencyItem.internalBinaryWrite(message.stickers[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.StickerFrecency
 */
export const FrecencyUserSettings_StickerFrecency = new FrecencyUserSettings_StickerFrecency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrecencyUserSettings_FavoriteEmojis$Type extends MessageType<FrecencyUserSettings_FavoriteEmojis> {
    constructor() {
        super("discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteEmojis", [
            { no: 1, name: "emojis", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FrecencyUserSettings_FavoriteEmojis>): FrecencyUserSettings_FavoriteEmojis {
        const message = { emojis: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FrecencyUserSettings_FavoriteEmojis>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrecencyUserSettings_FavoriteEmojis): FrecencyUserSettings_FavoriteEmojis {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string emojis */ 1:
                    message.emojis.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FrecencyUserSettings_FavoriteEmojis, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string emojis = 1; */
        for (let i = 0; i < message.emojis.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.emojis[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FavoriteEmojis
 */
export const FrecencyUserSettings_FavoriteEmojis = new FrecencyUserSettings_FavoriteEmojis$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrecencyUserSettings_EmojiFrecency$Type extends MessageType<FrecencyUserSettings_EmojiFrecency> {
    constructor() {
        super("discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.EmojiFrecency", [
            { no: 1, name: "emojis", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => FrecencyUserSettings_FrecencyItem } }
        ]);
    }
    create(value?: PartialMessage<FrecencyUserSettings_EmojiFrecency>): FrecencyUserSettings_EmojiFrecency {
        const message = { emojis: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FrecencyUserSettings_EmojiFrecency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrecencyUserSettings_EmojiFrecency): FrecencyUserSettings_EmojiFrecency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem> emojis */ 1:
                    this.binaryReadMap1(message.emojis, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: FrecencyUserSettings_EmojiFrecency["emojis"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FrecencyUserSettings_EmojiFrecency["emojis"] | undefined, val: FrecencyUserSettings_EmojiFrecency["emojis"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = FrecencyUserSettings_FrecencyItem.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.EmojiFrecency.emojis");
            }
        }
        map[key ?? ""] = val ?? FrecencyUserSettings_FrecencyItem.create();
    }
    internalBinaryWrite(message: FrecencyUserSettings_EmojiFrecency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem> emojis = 1; */
        for (let k of Object.keys(message.emojis)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            FrecencyUserSettings_FrecencyItem.internalBinaryWrite(message.emojis[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.EmojiFrecency
 */
export const FrecencyUserSettings_EmojiFrecency = new FrecencyUserSettings_EmojiFrecency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrecencyUserSettings_ApplicationCommandFrecency$Type extends MessageType<FrecencyUserSettings_ApplicationCommandFrecency> {
    constructor() {
        super("discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.ApplicationCommandFrecency", [
            { no: 1, name: "application_commands", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => FrecencyUserSettings_FrecencyItem } }
        ]);
    }
    create(value?: PartialMessage<FrecencyUserSettings_ApplicationCommandFrecency>): FrecencyUserSettings_ApplicationCommandFrecency {
        const message = { applicationCommands: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FrecencyUserSettings_ApplicationCommandFrecency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrecencyUserSettings_ApplicationCommandFrecency): FrecencyUserSettings_ApplicationCommandFrecency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem> application_commands */ 1:
                    this.binaryReadMap1(message.applicationCommands, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: FrecencyUserSettings_ApplicationCommandFrecency["applicationCommands"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FrecencyUserSettings_ApplicationCommandFrecency["applicationCommands"] | undefined, val: FrecencyUserSettings_ApplicationCommandFrecency["applicationCommands"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = FrecencyUserSettings_FrecencyItem.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.ApplicationCommandFrecency.application_commands");
            }
        }
        map[key ?? ""] = val ?? FrecencyUserSettings_FrecencyItem.create();
    }
    internalBinaryWrite(message: FrecencyUserSettings_ApplicationCommandFrecency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.FrecencyItem> application_commands = 1; */
        for (let k of Object.keys(message.applicationCommands)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            FrecencyUserSettings_FrecencyItem.internalBinaryWrite(message.applicationCommands[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message discord_protos.discord_users.v1.FrecencyUserSettings.FrecencyUserSettings.ApplicationCommandFrecency
 */
export const FrecencyUserSettings_ApplicationCommandFrecency = new FrecencyUserSettings_ApplicationCommandFrecency$Type();
